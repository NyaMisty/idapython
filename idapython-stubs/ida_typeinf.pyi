# mypy: disable-error-code="valid-type, name-defined, no-redef, assignment, misc, override"

import ida_idaapi
from _typeshed import Incomplete

def _swig_repr(self): ...
def _swig_setattr_nondynamic_instance_variable(set): ...
def _swig_setattr_nondynamic_class_variable(set): ...
def _swig_add_metaclass(metaclass): ...

class _SwigNonDynamicMeta(type):
    __setattr__: Incomplete

SWIG_PYTHON_LEGACY_BOOL: Incomplete
DEFMASK64: Incomplete

def deserialize_tinfo(*args) -> bool: ...

class funcargvec_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'funcarg_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'funcarg_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'funcarg_t *': ...
    def inject(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'qvector< funcarg_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< funcarg_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< funcarg_t >::iterator': ...
    def erase(self, *args) -> 'qvector< funcarg_t >::iterator': ...
    def find(self, *args) -> 'qvector< funcarg_t >::const_iterator': ...
    def has(self, *args) -> bool: ...
    def add_unique(self, *args) -> bool: ...
    def _del(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'funcarg_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class reginfovec_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'reg_info_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'reg_info_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'reg_info_t *': ...
    def inject(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'qvector< reg_info_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< reg_info_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< reg_info_t >::iterator': ...
    def erase(self, *args) -> 'qvector< reg_info_t >::iterator': ...
    def find(self, *args) -> 'qvector< reg_info_t >::const_iterator': ...
    def has(self, *args) -> bool: ...
    def add_unique(self, *args) -> bool: ...
    def _del(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'reg_info_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class edmvec_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'edm_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'edm_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'edm_t *': ...
    def inject(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'qvector< edm_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< edm_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< edm_t >::iterator': ...
    def erase(self, *args) -> 'qvector< edm_t >::iterator': ...
    def find(self, *args) -> 'qvector< edm_t >::const_iterator': ...
    def has(self, *args) -> bool: ...
    def add_unique(self, *args) -> bool: ...
    def _del(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'edm_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class argpartvec_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'argpart_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'argpart_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'argpart_t *': ...
    def inject(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'qvector< argpart_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< argpart_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< argpart_t >::iterator': ...
    def erase(self, *args) -> 'qvector< argpart_t >::iterator': ...
    def find(self, *args) -> 'qvector< argpart_t >::const_iterator': ...
    def has(self, *args) -> bool: ...
    def add_unique(self, *args) -> bool: ...
    def _del(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'argpart_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class valstrvec_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'valstr_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'valstr_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'valstr_t *': ...
    def inject(self, *args) -> None: ...
    def begin(self, *args) -> 'qvector< valstr_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< valstr_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< valstr_t >::iterator': ...
    def erase(self, *args) -> 'qvector< valstr_t >::iterator': ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'valstr_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class regobjvec_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'regobj_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'regobj_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'regobj_t *': ...
    def inject(self, *args) -> None: ...
    def begin(self, *args) -> 'qvector< regobj_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< regobj_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< regobj_t >::iterator': ...
    def erase(self, *args) -> 'qvector< regobj_t >::iterator': ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'regobj_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class type_attrs_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'type_attr_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'type_attr_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'type_attr_t *': ...
    def inject(self, *args) -> None: ...
    def begin(self, *args) -> 'qvector< type_attr_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< type_attr_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< type_attr_t >::iterator': ...
    def erase(self, *args) -> 'qvector< type_attr_t >::iterator': ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'type_attr_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class udtmembervec_template_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'udm_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'udm_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'udm_t *': ...
    def inject(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'qvector< udm_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< udm_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< udm_t >::iterator': ...
    def erase(self, *args) -> 'qvector< udm_t >::iterator': ...
    def find(self, *args) -> 'qvector< udm_t >::const_iterator': ...
    def has(self, *args) -> bool: ...
    def add_unique(self, *args) -> bool: ...
    def _del(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'udm_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

RESERVED_BYTE: Incomplete

def is_type_const(*args) -> bool: ...
def is_type_volatile(*args) -> bool: ...
def get_base_type(*args) -> type_t: ...
def get_type_flags(*args) -> type_t: ...
def get_full_type(*args) -> type_t: ...
def is_typeid_last(*args) -> bool: ...
def is_type_partial(*args) -> bool: ...
def is_type_void(*args) -> bool: ...
def is_type_unknown(*args) -> bool: ...
def is_type_ptr(*args) -> bool: ...
def is_type_complex(*args) -> bool: ...
def is_type_func(*args) -> bool: ...
def is_type_array(*args) -> bool: ...
def is_type_typedef(*args) -> bool: ...
def is_type_sue(*args) -> bool: ...
def is_type_struct(*args) -> bool: ...
def is_type_union(*args) -> bool: ...
def is_type_struni(*args) -> bool: ...
def is_type_enum(*args) -> bool: ...
def is_type_bitfld(*args) -> bool: ...
def is_type_int(*args) -> bool: ...
def is_type_int128(*args) -> bool: ...
def is_type_int64(*args) -> bool: ...
def is_type_int32(*args) -> bool: ...
def is_type_int16(*args) -> bool: ...
def is_type_char(*args) -> bool: ...
def is_type_paf(*args) -> bool: ...
def is_type_ptr_or_array(*args) -> bool: ...
def is_type_floating(*args) -> bool: ...
def is_type_integral(*args) -> bool: ...
def is_type_ext_integral(*args) -> bool: ...
def is_type_arithmetic(*args) -> bool: ...
def is_type_ext_arithmetic(*args) -> bool: ...
def is_type_uint(*args) -> bool: ...
def is_type_uchar(*args) -> bool: ...
def is_type_uint16(*args) -> bool: ...
def is_type_uint32(*args) -> bool: ...
def is_type_uint64(*args) -> bool: ...
def is_type_uint128(*args) -> bool: ...
def is_type_ldouble(*args) -> bool: ...
def is_type_double(*args) -> bool: ...
def is_type_float(*args) -> bool: ...
def is_type_tbyte(*args) -> bool: ...
def is_type_bool(*args) -> bool: ...

TAH_BYTE: Incomplete
FAH_BYTE: Incomplete
MAX_DECL_ALIGN: Incomplete
TAH_HASATTRS: Incomplete
TAUDT_UNALIGNED: Incomplete
TAUDT_MSSTRUCT: Incomplete
TAUDT_CPPOBJ: Incomplete
TAUDT_VFTABLE: Incomplete
TAFLD_BASECLASS: Incomplete
TAFLD_UNALIGNED: Incomplete
TAFLD_VIRTBASE: Incomplete
TAFLD_VFTABLE: Incomplete
TAFLD_METHOD: Incomplete
TAFLD_GAP: Incomplete
TAFLD_REGCMT: Incomplete
TAPTR_PTR32: Incomplete
TAPTR_PTR64: Incomplete
TAPTR_RESTRICT: Incomplete
TAPTR_SHIFTED: Incomplete
TAENUM_64BIT: Incomplete
TAENUM_UNSIGNED: Incomplete
TAENUM_SIGNED: Incomplete
TAENUM_OCT: Incomplete
TAENUM_BIN: Incomplete
TAENUM_NUMSIGN: Incomplete
TAENUM_LZERO: Incomplete
TAH_ALL: Incomplete

def is_tah_byte(*args) -> bool: ...
def is_sdacl_byte(*args) -> bool: ...

class type_attr_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    key: Incomplete
    value: Incomplete
    def __lt__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

cvar: Incomplete
TYPE_BASE_MASK: Incomplete
TYPE_FLAGS_MASK: Incomplete
TYPE_MODIF_MASK: Incomplete
TYPE_FULL_MASK: Incomplete
BT_UNK: Incomplete
BT_VOID: Incomplete
BTMT_SIZE0: Incomplete
BTMT_SIZE12: Incomplete
BTMT_SIZE48: Incomplete
BTMT_SIZE128: Incomplete
BT_INT8: Incomplete
BT_INT16: Incomplete
BT_INT32: Incomplete
BT_INT64: Incomplete
BT_INT128: Incomplete
BT_INT: Incomplete
BTMT_UNKSIGN: Incomplete
BTMT_SIGNED: Incomplete
BTMT_USIGNED: Incomplete
BTMT_UNSIGNED: Incomplete
BTMT_CHAR: Incomplete
BT_BOOL: Incomplete
BTMT_DEFBOOL: Incomplete
BTMT_BOOL1: Incomplete
BTMT_BOOL2: Incomplete
BTMT_BOOL8: Incomplete
BTMT_BOOL4: Incomplete
BT_FLOAT: Incomplete
BTMT_FLOAT: Incomplete
BTMT_DOUBLE: Incomplete
BTMT_LNGDBL: Incomplete
BTMT_SPECFLT: Incomplete
_BT_LAST_BASIC: Incomplete
BT_PTR: Incomplete
BTMT_DEFPTR: Incomplete
BTMT_NEAR: Incomplete
BTMT_FAR: Incomplete
BTMT_CLOSURE: Incomplete
BT_ARRAY: Incomplete
BTMT_NONBASED: Incomplete
BTMT_ARRESERV: Incomplete
BT_FUNC: Incomplete
BTMT_DEFCALL: Incomplete
BTMT_NEARCALL: Incomplete
BTMT_FARCALL: Incomplete
BTMT_INTCALL: Incomplete
BT_COMPLEX: Incomplete
BTMT_STRUCT: Incomplete
BTMT_UNION: Incomplete
BTMT_ENUM: Incomplete
BTMT_TYPEDEF: Incomplete
BT_BITFIELD: Incomplete
BTMT_BFLDI8: Incomplete
BTMT_BFLDI16: Incomplete
BTMT_BFLDI32: Incomplete
BTMT_BFLDI64: Incomplete
BT_RESERVED: Incomplete
BTM_CONST: Incomplete
BTM_VOLATILE: Incomplete
BTE_SIZE_MASK: Incomplete
BTE_RESERVED: Incomplete
BTE_BITMASK: Incomplete
BTE_OUT_MASK: Incomplete
BTE_HEX: Incomplete
BTE_CHAR: Incomplete
BTE_SDEC: Incomplete
BTE_UDEC: Incomplete
BTE_ALWAYS: Incomplete
BT_SEGREG: Incomplete
BT_UNK_BYTE: Incomplete
BT_UNK_WORD: Incomplete
BT_UNK_DWORD: Incomplete
BT_UNK_QWORD: Incomplete
BT_UNK_OWORD: Incomplete
BT_UNKNOWN: Incomplete
BTF_BYTE: Incomplete
BTF_UNK: Incomplete
BTF_VOID: Incomplete
BTF_INT8: Incomplete
BTF_CHAR: Incomplete
BTF_UCHAR: Incomplete
BTF_UINT8: Incomplete
BTF_INT16: Incomplete
BTF_UINT16: Incomplete
BTF_INT32: Incomplete
BTF_UINT32: Incomplete
BTF_INT64: Incomplete
BTF_UINT64: Incomplete
BTF_INT128: Incomplete
BTF_UINT128: Incomplete
BTF_INT: Incomplete
BTF_UINT: Incomplete
BTF_SINT: Incomplete
BTF_BOOL: Incomplete
BTF_FLOAT: Incomplete
BTF_DOUBLE: Incomplete
BTF_LDOUBLE: Incomplete
BTF_TBYTE: Incomplete
BTF_STRUCT: Incomplete
BTF_UNION: Incomplete
BTF_ENUM: Incomplete
BTF_TYPEDEF: Incomplete
TA_ORG_TYPEDEF: Incomplete
TA_ORG_ARRDIM: Incomplete
TA_FORMAT: Incomplete
TA_VALUE_REPR: Incomplete

def append_argloc(*args) -> bool: ...
def extract_argloc(*args) -> bool: ...
def resolve_typedef(*args) -> 'type_t const *': ...
def is_restype_void(*args) -> bool: ...
def is_restype_enum(*args) -> bool: ...
def is_restype_struni(*args) -> bool: ...
def is_restype_struct(*args) -> bool: ...
def get_scalar_bt(*args) -> type_t: ...

class til_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    name: Incomplete
    desc: Incomplete
    nbases: Incomplete
    flags: Incomplete
    def is_dirty(self, *args) -> bool: ...
    def set_dirty(self, *args) -> None: ...
    cc: Incomplete
    nrefs: Incomplete
    nstreams: Incomplete
    streams: Incomplete
    def base(self, *args) -> 'til_t *': ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

no_sign: Incomplete
type_signed: Incomplete
type_unsigned: Incomplete
TIL_ZIP: Incomplete
TIL_MAC: Incomplete
TIL_ESI: Incomplete
TIL_UNI: Incomplete
TIL_ORD: Incomplete
TIL_ALI: Incomplete
TIL_MOD: Incomplete
TIL_STM: Incomplete
TIL_SLD: Incomplete

def new_til(*args) -> 'til_t *': ...

TIL_ADD_FAILED: Incomplete
TIL_ADD_OK: Incomplete
TIL_ADD_ALREADY: Incomplete

def load_til(*args) -> 'qstring *': ...
def compact_til(*args) -> bool: ...
def store_til(*args) -> bool: ...
def free_til(*args) -> None: ...
def load_til_header(*args) -> 'qstring *': ...
def is_code_far(*args) -> bool: ...
def is_data_far(*args) -> bool: ...

class rrel_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    off: Incomplete
    reg: Incomplete
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

CM_MASK: Incomplete
CM_UNKNOWN: Incomplete
CM_N8_F16: Incomplete
CM_N64: Incomplete
CM_N16_F32: Incomplete
CM_N32_F48: Incomplete
CM_M_MASK: Incomplete
CM_M_NN: Incomplete
CM_M_FF: Incomplete
CM_M_NF: Incomplete
CM_M_FN: Incomplete
CM_CC_MASK: Incomplete
CM_CC_INVALID: Incomplete
CM_CC_UNKNOWN: Incomplete
CM_CC_VOIDARG: Incomplete
CM_CC_CDECL: Incomplete
CM_CC_ELLIPSIS: Incomplete
CM_CC_STDCALL: Incomplete
CM_CC_PASCAL: Incomplete
CM_CC_FASTCALL: Incomplete
CM_CC_THISCALL: Incomplete
CM_CC_SWIFT: Incomplete
CM_CC_SPOILED: Incomplete
CM_CC_GOLANG: Incomplete
CM_CC_RESERVE3: Incomplete
CM_CC_SPECIALE: Incomplete
CM_CC_SPECIALP: Incomplete
CM_CC_SPECIAL: Incomplete
BFA_NORET: Incomplete
BFA_PURE: Incomplete
BFA_HIGH: Incomplete
BFA_STATIC: Incomplete
BFA_VIRTUAL: Incomplete
BFA_FUNC_MARKER: Incomplete
BFA_FUNC_EXT_FORMAT: Incomplete
ALOC_NONE: Incomplete
ALOC_STACK: Incomplete
ALOC_DIST: Incomplete
ALOC_REG1: Incomplete
ALOC_REG2: Incomplete
ALOC_RREL: Incomplete
ALOC_STATIC: Incomplete
ALOC_CUSTOM: Incomplete

class argloc_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def swap(self, *args) -> None: ...
    def atype(self, *args) -> argloc_type_t: ...
    def is_reg1(self, *args) -> bool: ...
    def is_reg2(self, *args) -> bool: ...
    def is_reg(self, *args) -> bool: ...
    def is_rrel(self, *args) -> bool: ...
    def is_ea(self, *args) -> bool: ...
    def is_stkoff(self, *args) -> bool: ...
    def is_scattered(self, *args) -> bool: ...
    def has_reg(self, *args) -> bool: ...
    def has_stkoff(self, *args) -> bool: ...
    def is_mixed_scattered(self, *args) -> bool: ...
    def in_stack(self, *args) -> bool: ...
    def is_fragmented(self, *args) -> bool: ...
    def is_custom(self, *args) -> bool: ...
    def is_badloc(self, *args) -> bool: ...
    def reg1(self, *args) -> int: ...
    def regoff(self, *args) -> int: ...
    def reg2(self, *args) -> int: ...
    def get_reginfo(self, *args) -> uint32: ...
    def stkoff(self, *args) -> sval_t: ...
    def get_ea(self, *args) -> ea_t: ...
    def scattered(self, *args) -> 'scattered_aloc_t const &': ...
    def get_rrel(self, *args) -> 'rrel_t const &': ...
    def get_custom(self, *args) -> 'void *': ...
    def get_biggest(self, *args) -> 'argloc_t::biggest_t': ...
    def _set_badloc(self, *args) -> None: ...
    def _set_reg1(self, *args) -> None: ...
    def _set_reg2(self, *args) -> None: ...
    def _set_stkoff(self, *args) -> None: ...
    def _set_ea(self, *args) -> None: ...
    def _consume_rrel(self, *args) -> bool: ...
    def _consume_scattered(self, *args) -> bool: ...
    def _set_custom(self, *args) -> None: ...
    def _set_biggest(self, *args) -> None: ...
    def set_reg1(self, *args) -> None: ...
    def set_reg2(self, *args) -> None: ...
    def set_stkoff(self, *args) -> None: ...
    def set_ea(self, *args) -> None: ...
    def consume_rrel(self, *args) -> None: ...
    def set_badloc(self, *args) -> None: ...
    def calc_offset(self, *args) -> sval_t: ...
    def advance(self, *args) -> bool: ...
    def align_reg_high(self, *args) -> None: ...
    def align_stkoff_high(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def consume_scattered(self, *args) -> None: ...

class argpart_t(argloc_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    off: Incomplete
    size: Incomplete
    def __init__(self, *args) -> None: ...
    def bad_offset(self, *args) -> bool: ...
    def bad_size(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def swap(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class scattered_aloc_t(argpartvec_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

def verify_argloc(*args) -> int: ...
def optimize_argloc(*args) -> bool: ...
def print_argloc(*args) -> size_t: ...

PRALOC_VERIFY: Incomplete
PRALOC_STKOFF: Incomplete

class aloc_visitor_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def visit_location(self, *args) -> int: ...
    __swig_destroy__: Incomplete
    def __init__(self, *args) -> None: ...
    def __disown__(self): ...

def for_all_arglocs(*args) -> int: ...

class const_aloc_visitor_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def visit_location(self, *args) -> int: ...
    __swig_destroy__: Incomplete
    def __init__(self, *args) -> None: ...
    def __disown__(self): ...

def for_all_const_arglocs(*args) -> int: ...
def is_user_cc(*args) -> bool: ...
def is_vararg_cc(*args) -> bool: ...
def is_purging_cc(*args) -> bool: ...
def is_golang_cc(*args) -> bool: ...
def is_swift_cc(*args) -> bool: ...

ARGREGS_POLICY_UNDEFINED: Incomplete
ARGREGS_GP_ONLY: Incomplete
ARGREGS_INDEPENDENT: Incomplete
ARGREGS_BY_SLOTS: Incomplete
ARGREGS_FP_CONSUME_GP: Incomplete
ARGREGS_MIPS_O32: Incomplete

class callregs_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    policy: Incomplete
    nregs: Incomplete
    gpregs: Incomplete
    fpregs: Incomplete
    def __init__(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def init_regs(self, *args) -> None: ...
    def by_slots(self, *args) -> bool: ...
    def set(self, *args) -> None: ...
    def reset(self, *args) -> None: ...
    @staticmethod
    def regcount(*args) -> int: ...
    def reginds(self, *args) -> bool: ...
    __swig_destroy__: Incomplete

C_PC_TINY: Incomplete
C_PC_SMALL: Incomplete
C_PC_COMPACT: Incomplete
C_PC_MEDIUM: Incomplete
C_PC_LARGE: Incomplete
C_PC_HUGE: Incomplete
C_PC_FLAT: Incomplete

def callregs_t_regcount(*args) -> int: ...
def get_comp(*args) -> comp_t: ...
def get_compiler_name(*args) -> 'char const *': ...
def get_compiler_abbr(*args) -> 'char const *': ...
def get_compilers(*args) -> None: ...
def is_comp_unsure(*args) -> comp_t: ...
def default_compiler(*args) -> comp_t: ...
def is_gcc(*args) -> bool: ...
def is_gcc32(*args) -> bool: ...
def is_gcc64(*args) -> bool: ...
def gcc_layout(*args) -> bool: ...
def set_compiler(*args) -> bool: ...

SETCOMP_OVERRIDE: Incomplete
SETCOMP_ONLY_ID: Incomplete
SETCOMP_ONLY_ABI: Incomplete
SETCOMP_BY_USER: Incomplete

def set_compiler_id(*args) -> bool: ...
def set_abi_name(*args) -> bool: ...
def get_abi_name(*args) -> 'qstring *': ...
def append_abi_opts(*args) -> bool: ...
def remove_abi_opts(*args) -> bool: ...
def set_compiler_string(*args) -> bool: ...
def use_golang_cc(*args) -> bool: ...
def switch_to_golang(*args) -> None: ...

MAX_FUNC_ARGS: Incomplete
ABS_UNK: Incomplete
ABS_NO: Incomplete
ABS_YES: Incomplete
SC_UNK: Incomplete
SC_TYPE: Incomplete
SC_EXT: Incomplete
SC_STAT: Incomplete
SC_REG: Incomplete
SC_AUTO: Incomplete
SC_FRIEND: Incomplete
SC_VIRT: Incomplete
HTI_CPP: Incomplete
HTI_INT: Incomplete
HTI_EXT: Incomplete
HTI_LEX: Incomplete
HTI_UNP: Incomplete
HTI_TST: Incomplete
HTI_FIL: Incomplete
HTI_MAC: Incomplete
HTI_NWR: Incomplete
HTI_NER: Incomplete
HTI_DCL: Incomplete
HTI_NDC: Incomplete
HTI_PAK: Incomplete
HTI_PAK_SHIFT: Incomplete
HTI_PAKDEF: Incomplete
HTI_PAK1: Incomplete
HTI_PAK2: Incomplete
HTI_PAK4: Incomplete
HTI_PAK8: Incomplete
HTI_PAK16: Incomplete
HTI_HIGH: Incomplete
HTI_LOWER: Incomplete
HTI_RAWARGS: Incomplete
HTI_RELAXED: Incomplete
HTI_NOBASE: Incomplete

def convert_pt_flags_to_hti(*args) -> int: ...
def parse_decl(*args) -> 'qstring *': ...

PT_SIL: Incomplete
PT_NDC: Incomplete
PT_TYP: Incomplete
PT_VAR: Incomplete
PT_PACKMASK: Incomplete
PT_HIGH: Incomplete
PT_LOWER: Incomplete
PT_REPLACE: Incomplete
PT_RAWARGS: Incomplete
PT_RELAXED: Incomplete

def parse_decls(*args) -> int: ...
def print_type(*args) -> 'qstring *': ...

PRTYPE_1LINE: Incomplete
PRTYPE_MULTI: Incomplete
PRTYPE_TYPE: Incomplete
PRTYPE_PRAGMA: Incomplete
PRTYPE_SEMI: Incomplete
PRTYPE_CPP: Incomplete
PRTYPE_DEF: Incomplete
PRTYPE_NOARGS: Incomplete
PRTYPE_NOARRS: Incomplete
PRTYPE_NORES: Incomplete
PRTYPE_RESTORE: Incomplete
PRTYPE_NOREGEX: Incomplete
PRTYPE_COLORED: Incomplete
PRTYPE_METHODS: Incomplete
PRTYPE_1LINCMT: Incomplete
PRTYPE_HEADER: Incomplete
PRTYPE_MAXSTR: Incomplete
NTF_TYPE: Incomplete
NTF_SYMU: Incomplete
NTF_SYMM: Incomplete
NTF_NOBASE: Incomplete
NTF_REPLACE: Incomplete
NTF_UMANGLED: Incomplete
NTF_NOCUR: Incomplete
NTF_64BIT: Incomplete
NTF_FIXNAME: Incomplete
NTF_IDBENC: Incomplete
NTF_CHKSYNC: Incomplete
NTF_NO_NAMECHK: Incomplete
NTF_COPY: Incomplete
TERR_OK: Incomplete
TERR_SAVE_ERROR: Incomplete
TERR_SERIALIZE: Incomplete
TERR_BAD_NAME: Incomplete
TERR_BAD_SYNC: Incomplete
TERR_BAD_ARG: Incomplete
TERR_BAD_TYPE: Incomplete
TERR_BAD_SIZE: Incomplete
TERR_BAD_INDEX: Incomplete
TERR_BAD_ARRAY: Incomplete
TERR_BAD_BF: Incomplete
TERR_BAD_OFFSET: Incomplete
TERR_BAD_UNIVAR: Incomplete
TERR_BAD_VARLAST: Incomplete
TERR_OVERLAP: Incomplete
TERR_BAD_SUBTYPE: Incomplete
TERR_BAD_VALUE: Incomplete
TERR_NO_BMASK: Incomplete
TERR_BAD_BMASK: Incomplete
TERR_BAD_MSKVAL: Incomplete
TERR_BAD_REPR: Incomplete
TERR_GRP_NOEMPTY: Incomplete
TERR_DUPNAME: Incomplete
TERR_UNION_BF: Incomplete
TERR_BAD_TAH: Incomplete
TERR_BAD_BASE: Incomplete
TERR_BAD_GAP: Incomplete
TERR_NESTED: Incomplete
TERR_NOT_COMPAT: Incomplete
TERR_BAD_LAYOUT: Incomplete
TERR_BAD_GROUPS: Incomplete
TERR_BAD_SERIAL: Incomplete
TERR_ALIEN_NAME: Incomplete
TERR_STOCK: Incomplete
TERR_ENUM_SIZE: Incomplete
TERR_NOT_IMPL: Incomplete
TERR_COUNT: Incomplete

def tinfo_errstr(*args) -> 'char const *': ...
def del_named_type(*args) -> bool: ...
def first_named_type(*args) -> 'char const *': ...
def next_named_type(*args) -> 'char const *': ...
def copy_named_type(*args) -> uint32: ...
def gen_decorate_name(*args) -> 'qstring *': ...
def calc_c_cpp_name(*args) -> 'qstring *': ...

CCN_C: Incomplete
CCN_CPP: Incomplete

def enable_numbered_types(*args) -> bool: ...
def alloc_type_ordinals(*args) -> uint32: ...
def alloc_type_ordinal(*args) -> uint32: ...
def get_ordinal_limit(*args) -> uint32: ...
def get_ordinal_count(*args) -> uint32: ...
def set_numbered_type(*args) -> tinfo_code_t: ...
def del_numbered_type(*args) -> bool: ...
def set_type_alias(*args) -> bool: ...
def get_alias_target(*args) -> uint32: ...
def get_type_ordinal(*args) -> int32: ...
def get_numbered_type_name(*args) -> 'char const *': ...
def create_numbered_type_name(*args) -> 'qstring *': ...
def is_ordinal_name(*args) -> bool: ...
def get_ordinal_from_idb_type(*args) -> int: ...
def is_autosync(*args) -> bool: ...
def is_type_choosable(*args) -> bool: ...
def set_type_choosable(*args) -> None: ...
def get_vftable_ea(*args) -> ea_t: ...
def get_vftable_ordinal(*args) -> uint32: ...
def set_vftable_ea(*args) -> bool: ...
def del_vftable_ea(*args) -> bool: ...
def deref_ptr(*args) -> bool: ...
def import_type(*args) -> tid_t: ...

IMPTYPE_LOCAL: Incomplete

def add_til(*args) -> int: ...

ADDTIL_DEFAULT: Incomplete
ADDTIL_INCOMP: Incomplete
ADDTIL_SILENT: Incomplete
ADDTIL_FAILED: Incomplete
ADDTIL_OK: Incomplete
ADDTIL_COMP: Incomplete
ADDTIL_ABORTED: Incomplete

def del_til(*args) -> bool: ...
def apply_named_type(*args) -> bool: ...
def apply_tinfo(*args) -> bool: ...

TINFO_GUESSED: Incomplete
TINFO_DEFINITE: Incomplete
TINFO_DELAYFUNC: Incomplete
TINFO_STRICT: Incomplete

def apply_cdecl(*args) -> bool: ...
def apply_callee_tinfo(*args) -> bool: ...
def apply_once_tinfo_and_name(*args) -> bool: ...
def guess_tinfo(*args) -> int: ...

GUESS_FUNC_FAILED: Incomplete
GUESS_FUNC_TRIVIAL: Incomplete
GUESS_FUNC_OK: Incomplete

def set_c_header_path(*args) -> None: ...
def get_c_header_path(*args) -> 'qstring *': ...
def set_c_macros(*args) -> None: ...
def get_c_macros(*args) -> 'qstring *': ...
def get_idati(*args) -> 'til_t *': ...
def get_idainfo_by_type(*args) -> 'size_t *, flags_t *, opinfo_t *, size_t *': ...
def get_idainfo64_by_type(*args) -> 'size_t *, opinfo_t *, size_t *': ...
def get_tinfo_by_flags(*args) -> bool: ...

STI_PCHAR: Incomplete
STI_PUCHAR: Incomplete
STI_PCCHAR: Incomplete
STI_PCUCHAR: Incomplete
STI_PBYTE: Incomplete
STI_PINT: Incomplete
STI_PUINT: Incomplete
STI_PVOID: Incomplete
STI_PPVOID: Incomplete
STI_PCVOID: Incomplete
STI_ACHAR: Incomplete
STI_AUCHAR: Incomplete
STI_ACCHAR: Incomplete
STI_ACUCHAR: Incomplete
STI_FPURGING: Incomplete
STI_FDELOP: Incomplete
STI_MSGSEND: Incomplete
STI_AEABI_LCMP: Incomplete
STI_AEABI_ULCMP: Incomplete
STI_DONT_USE: Incomplete
STI_SIZE_T: Incomplete
STI_SSIZE_T: Incomplete
STI_AEABI_MEMCPY: Incomplete
STI_AEABI_MEMSET: Incomplete
STI_AEABI_MEMCLR: Incomplete
STI_RTC_CHECK_2: Incomplete
STI_RTC_CHECK_4: Incomplete
STI_RTC_CHECK_8: Incomplete
STI_COMPLEX64: Incomplete
STI_COMPLEX128: Incomplete
STI_LAST: Incomplete
ETF_NO_SAVE: Incomplete
ETF_NO_LAYOUT: Incomplete
ETF_MAY_DESTROY: Incomplete
ETF_COMPATIBLE: Incomplete
ETF_FUNCARG: Incomplete
ETF_FORCENAME: Incomplete
ETF_AUTONAME: Incomplete
ETF_ASMENUM: Incomplete
ETF_NO_IDBSYNC: Incomplete
GTD_CALC_LAYOUT: Incomplete
GTD_NO_LAYOUT: Incomplete
GTD_DEL_BITFLDS: Incomplete
GTD_CALC_ARGLOCS: Incomplete
GTD_NO_ARGLOCS: Incomplete
GTS_NESTED: Incomplete
GTS_BASECLASS: Incomplete
SUDT_SORT: Incomplete
SUDT_ALIGN: Incomplete
SUDT_GAPS: Incomplete
SUDT_UNEX: Incomplete
SUDT_FAST: Incomplete
SUDT_CONST: Incomplete
SUDT_VOLATILE: Incomplete
SUDT_TRUNC: Incomplete
SUDT_SERDEF: Incomplete

def copy_tinfo_t(*args) -> None: ...
def clear_tinfo_t(*args) -> None: ...
def create_tinfo2(*args) -> bool: ...
def verify_tinfo(*args) -> int: ...
def get_tinfo_details2(*args) -> bool: ...
def get_tinfo_size(*args) -> size_t: ...
def get_tinfo_pdata(*args) -> size_t: ...
def get_tinfo_property(*args) -> size_t: ...
def get_tinfo_property4(*args) -> size_t: ...
def set_tinfo_property(*args) -> size_t: ...
def set_tinfo_property4(*args) -> size_t: ...
def serialize_tinfo(*args) -> bool: ...
def find_tinfo_udt_member(*args) -> int: ...
def print_tinfo(*args) -> 'qstring *': ...
def dstr_tinfo(*args) -> 'char const *': ...
def visit_subtypes(*args) -> int: ...
def compare_tinfo(*args) -> bool: ...
def lexcompare_tinfo(*args) -> int: ...
def get_stock_tinfo(*args) -> bool: ...
def read_tinfo_bitfield_value(*args) -> uint64: ...
def write_tinfo_bitfield_value(*args) -> uint64: ...
def get_tinfo_attr(*args) -> bool: ...
def set_tinfo_attr(*args) -> bool: ...
def del_tinfo_attr(*args) -> bool: ...
def get_tinfo_attrs(*args) -> bool: ...
def set_tinfo_attrs(*args) -> bool: ...
def score_tinfo(*args) -> uint32: ...
def save_tinfo(*args) -> tinfo_code_t: ...
def append_tinfo_covered(*args) -> bool: ...
def calc_tinfo_gaps(*args) -> bool: ...
def value_repr_t__from_opinfo(*args) -> bool: ...
def value_repr_t__print_(*args) -> 'qstring *': ...
def udt_type_data_t__find_member(*args) -> ssize_t: ...
def udm_t__make_gap(*args) -> bool: ...
def udt_type_data_t__get_best_fit_member(*args) -> ssize_t: ...
def get_udm_tid(*args) -> tid_t: ...
def enum_type_data_t__get_max_serial(*args) -> uchar: ...
def get_tinfo_tid(*args) -> tid_t: ...

class tinfo_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def get_named_type(self, *args) -> bool: ...
    def get_numbered_type(self, *args) -> bool: ...
    def is_correct(self, *args) -> bool: ...
    def get_realtype(self, *args) -> type_t: ...
    def get_decltype(self, *args) -> type_t: ...
    def empty(self, *args) -> bool: ...
    def present(self, *args) -> bool: ...
    def get_size(self, *args) -> size_t: ...
    def get_unpadded_size(self, *args) -> size_t: ...
    def get_sign(self, *args) -> type_sign_t: ...
    def is_signed(self, *args) -> bool: ...
    def is_unsigned(self, *args) -> bool: ...
    def get_declalign(self, *args) -> uchar: ...
    def is_typeref(self, *args) -> bool: ...
    def has_details(self, *args) -> bool: ...
    def get_type_name(self, *args) -> bool: ...
    def get_nice_type_name(self, *args) -> bool: ...
    def rename_type(self, *args) -> tinfo_code_t: ...
    def get_final_type_name(self, *args) -> bool: ...
    def get_next_type_name(self, *args) -> bool: ...
    def get_tid(self, *args) -> tid_t: ...
    def force_tid(self, *args) -> tid_t: ...
    def get_ordinal(self, *args) -> uint32: ...
    def get_final_ordinal(self, *args) -> uint32: ...
    def get_til(self, *args) -> 'til_t *': ...
    def is_from_subtil(self, *args) -> bool: ...
    def is_forward_decl(self, *args) -> bool: ...
    def get_forward_type(self, *args) -> type_t: ...
    def is_forward_struct(self, *args) -> bool: ...
    def is_forward_union(self, *args) -> bool: ...
    def is_forward_enum(self, *args) -> bool: ...
    def is_typedef(self, *args) -> bool: ...
    def get_type_cmt(self, *args) -> int: ...
    def get_type_rptcmt(self, *args) -> bool: ...
    def is_decl_const(self, *args) -> bool: ...
    def is_decl_volatile(self, *args) -> bool: ...
    def is_decl_void(self, *args) -> bool: ...
    def is_decl_partial(self, *args) -> bool: ...
    def is_decl_unknown(self, *args) -> bool: ...
    def is_decl_last(self, *args) -> bool: ...
    def is_decl_ptr(self, *args) -> bool: ...
    def is_decl_array(self, *args) -> bool: ...
    def is_decl_func(self, *args) -> bool: ...
    def is_decl_complex(self, *args) -> bool: ...
    def is_decl_typedef(self, *args) -> bool: ...
    def is_decl_sue(self, *args) -> bool: ...
    def is_decl_struct(self, *args) -> bool: ...
    def is_decl_union(self, *args) -> bool: ...
    def is_decl_udt(self, *args) -> bool: ...
    def is_decl_enum(self, *args) -> bool: ...
    def is_decl_bitfield(self, *args) -> bool: ...
    def is_decl_int128(self, *args) -> bool: ...
    def is_decl_int64(self, *args) -> bool: ...
    def is_decl_int32(self, *args) -> bool: ...
    def is_decl_int16(self, *args) -> bool: ...
    def is_decl_int(self, *args) -> bool: ...
    def is_decl_char(self, *args) -> bool: ...
    def is_decl_uint(self, *args) -> bool: ...
    def is_decl_uchar(self, *args) -> bool: ...
    def is_decl_uint16(self, *args) -> bool: ...
    def is_decl_uint32(self, *args) -> bool: ...
    def is_decl_uint64(self, *args) -> bool: ...
    def is_decl_uint128(self, *args) -> bool: ...
    def is_decl_ldouble(self, *args) -> bool: ...
    def is_decl_double(self, *args) -> bool: ...
    def is_decl_float(self, *args) -> bool: ...
    def is_decl_tbyte(self, *args) -> bool: ...
    def is_decl_floating(self, *args) -> bool: ...
    def is_decl_bool(self, *args) -> bool: ...
    def is_decl_paf(self, *args) -> bool: ...
    def is_well_defined(self, *args) -> bool: ...
    def is_const(self, *args) -> bool: ...
    def is_volatile(self, *args) -> bool: ...
    def is_void(self, *args) -> bool: ...
    def is_partial(self, *args) -> bool: ...
    def is_unknown(self, *args) -> bool: ...
    def is_ptr(self, *args) -> bool: ...
    def is_array(self, *args) -> bool: ...
    def is_func(self, *args) -> bool: ...
    def is_complex(self, *args) -> bool: ...
    def is_struct(self, *args) -> bool: ...
    def is_union(self, *args) -> bool: ...
    def is_udt(self, *args) -> bool: ...
    def is_enum(self, *args) -> bool: ...
    def is_sue(self, *args) -> bool: ...
    def is_bitfield(self, *args) -> bool: ...
    def is_int128(self, *args) -> bool: ...
    def is_int64(self, *args) -> bool: ...
    def is_int32(self, *args) -> bool: ...
    def is_int16(self, *args) -> bool: ...
    def is_int(self, *args) -> bool: ...
    def is_char(self, *args) -> bool: ...
    def is_uint(self, *args) -> bool: ...
    def is_uchar(self, *args) -> bool: ...
    def is_uint16(self, *args) -> bool: ...
    def is_uint32(self, *args) -> bool: ...
    def is_uint64(self, *args) -> bool: ...
    def is_uint128(self, *args) -> bool: ...
    def is_ldouble(self, *args) -> bool: ...
    def is_double(self, *args) -> bool: ...
    def is_float(self, *args) -> bool: ...
    def is_tbyte(self, *args) -> bool: ...
    def is_bool(self, *args) -> bool: ...
    def is_paf(self, *args) -> bool: ...
    def is_ptr_or_array(self, *args) -> bool: ...
    def is_integral(self, *args) -> bool: ...
    def is_ext_integral(self, *args) -> bool: ...
    def is_floating(self, *args) -> bool: ...
    def is_arithmetic(self, *args) -> bool: ...
    def is_ext_arithmetic(self, *args) -> bool: ...
    def is_scalar(self, *args) -> bool: ...
    def get_ptr_details(self, *args) -> bool: ...
    def get_array_details(self, *args) -> bool: ...
    def get_enum_details(self, *args) -> bool: ...
    def get_bitfield_details(self, *args) -> bool: ...
    def get_udt_details(self, *args) -> bool: ...
    def get_func_details(self, *args) -> bool: ...
    def is_funcptr(self, *args) -> bool: ...
    def is_shifted_ptr(self, *args) -> bool: ...
    def is_varstruct(self, *args) -> bool: ...
    def is_varmember(self, *args) -> bool: ...
    def get_ptrarr_objsize(self, *args) -> int: ...
    def get_ptrarr_object(self, *args) -> tinfo_t: ...
    def get_pointed_object(self, *args) -> tinfo_t: ...
    def is_pvoid(self, *args) -> bool: ...
    def get_array_element(self, *args) -> tinfo_t: ...
    def get_final_element(self, *args) -> tinfo_t: ...
    def get_array_nelems(self, *args) -> int: ...
    def get_nth_arg(self, *args) -> tinfo_t: ...
    def get_rettype(self, *args) -> tinfo_t: ...
    def get_nargs(self, *args) -> int: ...
    def is_user_cc(self, *args) -> bool: ...
    def is_vararg_cc(self, *args) -> bool: ...
    def is_purging_cc(self, *args) -> bool: ...
    def calc_purged_bytes(self, *args) -> int: ...
    def is_high_func(self, *args) -> bool: ...
    def get_methods(self, *args) -> bool: ...
    def get_bit_buckets(self, *args) -> bool: ...
    def find_udm(self, *args) -> int: ...
    def get_udt_nmembers(self, *args) -> int: ...
    def is_empty_udt(self, *args) -> bool: ...
    def is_small_udt(self, *args) -> bool: ...
    def requires_qualifier(self, *args) -> bool: ...
    def append_covered(self, *args) -> bool: ...
    def calc_gaps(self, *args) -> bool: ...
    def is_one_fpval(self, *args) -> bool: ...
    def is_sse_type(self, *args) -> bool: ...
    def is_anonymous_udt(self, *args) -> bool: ...
    def is_vftable(self, *args) -> bool: ...
    def has_vftable(self, *args) -> bool: ...
    def has_union(self, *args) -> bool: ...
    def get_enum_base_type(self, *args) -> type_t: ...
    def is_bitmask_enum(self, *args) -> bool: ...
    def get_enum_radix(self, *args) -> int: ...
    def get_edm(self, *args) -> tinfo_code_t: ...
    def find_edm(self, *args) -> tinfo_code_t: ...
    def get_onemember_type(self, *args) -> tinfo_t: ...
    def get_innermost_udm(self, *args) -> tinfo_t: ...
    def calc_score(self, *args) -> uint32: ...
    def _print(self, *args) -> bool: ...
    def dstr(self, *args) -> 'char const *': ...
    def get_attrs(self, *args) -> bool: ...
    def set_attrs(self, *args) -> bool: ...
    def set_attr(self, *args) -> bool: ...
    def del_attrs(self, *args) -> None: ...
    def del_attr(self, *args) -> bool: ...
    def create_simple_type(self, *args) -> bool: ...
    def create_ptr(self, *args) -> bool: ...
    def create_array(self, *args) -> bool: ...
    def create_typedef(self, *args) -> None: ...
    def create_bitfield(self, *args) -> bool: ...
    def parse(self, *args) -> bool: ...
    def create_udt(self, *args) -> bool: ...
    def create_enum(self, *args) -> bool: ...
    def create_func(self, *args) -> bool: ...
    def get_udm_by_tid(self, *args) -> ssize_t: ...
    def get_edm_by_tid(self, *args) -> ssize_t: ...
    def get_type_by_tid(self, *args) -> bool: ...
    def get_type_by_edm_name(self, *args) -> bool: ...
    def set_named_type(self, *args) -> tinfo_code_t: ...
    def set_symbol_type(self, *args) -> tinfo_code_t: ...
    def set_numbered_type(self, *args) -> tinfo_code_t: ...
    def save_type(self, *args) -> tinfo_code_t: ...
    def copy_type(self, *args) -> tinfo_code_t: ...
    def create_forward_decl(self, *args) -> tinfo_code_t: ...
    @staticmethod
    def get_stock(*args) -> tinfo_t: ...
    def convert_array_to_ptr(self, *args) -> bool: ...
    def remove_ptr_or_array(self, *args) -> bool: ...
    def read_bitfield_value(self, *args) -> uint64: ...
    def write_bitfield_value(self, *args) -> uint64: ...
    def get_modifiers(self, *args) -> type_t: ...
    def set_modifiers(self, *args) -> None: ...
    def set_const(self, *args) -> None: ...
    def set_volatile(self, *args) -> None: ...
    def clr_decl_const_volatile(self, *args) -> None: ...
    def clr_const(self, *args) -> bool: ...
    def clr_volatile(self, *args) -> bool: ...
    def clr_const_volatile(self, *args) -> bool: ...
    def set_type_alignment(self, *args) -> tinfo_code_t: ...
    def set_declalign(self, *args) -> bool: ...
    def change_sign(self, *args) -> bool: ...
    def calc_udt_aligns(self, *args) -> bool: ...
    def set_methods(self, *args) -> bool: ...
    def set_type_cmt(self, *args) -> tinfo_code_t: ...
    def get_alias_target(self, *args) -> uint32: ...
    def is_aliased(self, *args) -> bool: ...
    def set_type_alias(self, *args) -> bool: ...
    def set_udt_alignment(self, *args) -> tinfo_code_t: ...
    def set_udt_pack(self, *args) -> tinfo_code_t: ...
    def get_udm_tid(self, *args) -> tid_t: ...
    def add_udm(self, *args) -> tinfo_code_t: ...
    def del_udm(self, *args) -> tinfo_code_t: ...
    def del_udms(self, *args) -> tinfo_code_t: ...
    def rename_udm(self, *args) -> tinfo_code_t: ...
    def set_udm_type(self, *args) -> tinfo_code_t: ...
    def set_udm_cmt(self, *args) -> tinfo_code_t: ...
    def set_udm_repr(self, *args) -> tinfo_code_t: ...
    def expand_udt(self, *args) -> tinfo_code_t: ...
    def set_enum_width(self, *args) -> tinfo_code_t: ...
    def set_enum_sign(self, *args) -> tinfo_code_t: ...
    ENUMBM_OFF: Incomplete
    ENUMBM_ON: Incomplete
    ENUMBM_AUTO: Incomplete
    def set_enum_is_bitmask(self, *args) -> tinfo_code_t: ...
    def set_enum_repr(self, *args) -> tinfo_code_t: ...
    def add_edm(self, *args) -> tinfo_code_t: ...
    def del_edms(self, *args) -> tinfo_code_t: ...
    def del_edm(self, *args) -> tinfo_code_t: ...
    def rename_edm(self, *args) -> tinfo_code_t: ...
    def set_edm_cmt(self, *args) -> tinfo_code_t: ...
    def edit_edm(self, *args) -> tinfo_code_t: ...
    def edit_udt(self, *args) -> tinfo_code_t: ...
    def edit_enum(self, *args) -> tinfo_code_t: ...
    def edit_func(self, *args) -> tinfo_code_t: ...
    def edit_array(self, *args) -> tinfo_code_t: ...
    def edit_ptr(self, *args) -> tinfo_code_t: ...
    def edit_bitfield(self, *args) -> tinfo_code_t: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def compare_with(self, *args) -> bool: ...
    def equals_to(self, *args) -> bool: ...
    def is_castable_to(self, *args) -> bool: ...
    def is_manually_castable_to(self, *args) -> bool: ...
    def serialize(self, *args) -> 'PyObject *': ...
    def deserialize(self, *args) -> bool: ...
    def copy(self, *args) -> tinfo_t: ...
    def __str__(self, *args) -> qstring: ...
    __swig_destroy__: Incomplete
    def get_attr(self, *args) -> 'PyObject *': ...

COMP_MASK: Incomplete
COMP_UNK: Incomplete
COMP_MS: Incomplete
COMP_BC: Incomplete
COMP_WATCOM: Incomplete
COMP_GNU: Incomplete
COMP_VISAGE: Incomplete
COMP_BP: Incomplete
COMP_UNSURE: Incomplete
BADSIZE: Incomplete
FIRST_NONTRIVIAL_TYPID: Incomplete
TYPID_ISREF: Incomplete
TYPID_SHIFT: Incomplete

def remove_pointer(*args) -> tinfo_t: ...

STRMEM_MASK: Incomplete
STRMEM_OFFSET: Incomplete
STRMEM_INDEX: Incomplete
STRMEM_AUTO: Incomplete
STRMEM_NAME: Incomplete
STRMEM_TYPE: Incomplete
STRMEM_SIZE: Incomplete
STRMEM_MINS: Incomplete
STRMEM_MAXS: Incomplete
STRMEM_VFTABLE: Incomplete
STRMEM_SKIP_EMPTY: Incomplete
STRMEM_CASTABLE_TO: Incomplete
STRMEM_ANON: Incomplete

def tinfo_t_get_stock(*args) -> tinfo_t: ...

TCMP_EQUAL: Incomplete
TCMP_IGNMODS: Incomplete
TCMP_AUTOCAST: Incomplete
TCMP_MANCAST: Incomplete
TCMP_CALL: Incomplete
TCMP_DELPTR: Incomplete
TCMP_DECL: Incomplete
TCMP_ANYBASE: Incomplete
TCMP_SKIPTHIS: Incomplete

class simd_info_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    name: Incomplete
    tif: Incomplete
    size: Incomplete
    memtype: Incomplete
    def __init__(self, *args) -> None: ...
    def match_pattern(self, *args) -> bool: ...
    __swig_destroy__: Incomplete

def guess_func_cc(*args) -> cm_t: ...
def dump_func_type_data(*args) -> 'qstring *': ...

class ptr_type_data_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    obj_type: Incomplete
    closure: Incomplete
    based_ptr_size: Incomplete
    taptr_bits: Incomplete
    parent: Incomplete
    delta: Incomplete
    def __init__(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def is_code_ptr(self, *args) -> bool: ...
    def is_shifted(self, *args) -> bool: ...
    __swig_destroy__: Incomplete

class array_type_data_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    elem_type: Incomplete
    base: Incomplete
    nelems: Incomplete
    def __init__(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class funcarg_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    argloc: Incomplete
    name: Incomplete
    cmt: Incomplete
    type: Incomplete
    flags: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

FAI_HIDDEN: Incomplete
FAI_RETPTR: Incomplete
FAI_STRUCT: Incomplete
FAI_ARRAY: Incomplete
FAI_UNUSED: Incomplete

class func_type_data_t(funcargvec_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    flags: Incomplete
    rettype: Incomplete
    retloc: Incomplete
    stkargs: Incomplete
    spoiled: Incomplete
    cc: Incomplete
    def swap(self, *args) -> None: ...
    def is_high(self, *args) -> bool: ...
    def is_noret(self, *args) -> bool: ...
    def is_pure(self, *args) -> bool: ...
    def is_static(self, *args) -> bool: ...
    def is_virtual(self, *args) -> bool: ...
    def is_const(self, *args) -> bool: ...
    def is_ctor(self, *args) -> bool: ...
    def is_dtor(self, *args) -> bool: ...
    def get_call_method(self, *args) -> int: ...
    def is_vararg_cc(self, *args) -> bool: ...
    def is_golang_cc(self, *args) -> bool: ...
    def is_swift_cc(self, *args) -> bool: ...
    def guess_cc(self, *args) -> cm_t: ...
    def dump(self, *args) -> bool: ...
    __swig_destroy__: Incomplete
    def __init__(self, *args) -> None: ...

FTI_SPOILED: Incomplete
FTI_NORET: Incomplete
FTI_PURE: Incomplete
FTI_HIGH: Incomplete
FTI_STATIC: Incomplete
FTI_VIRTUAL: Incomplete
FTI_CALLTYPE: Incomplete
FTI_DEFCALL: Incomplete
FTI_NEARCALL: Incomplete
FTI_FARCALL: Incomplete
FTI_INTCALL: Incomplete
FTI_ARGLOCS: Incomplete
FTI_EXPLOCS: Incomplete
FTI_CONST: Incomplete
FTI_CTOR: Incomplete
FTI_DTOR: Incomplete
FTI_ALL: Incomplete
CC_CDECL_OK: Incomplete
CC_ALLOW_ARGPERM: Incomplete
CC_ALLOW_REGHOLES: Incomplete
CC_HAS_ELLIPSIS: Incomplete
CC_GOLANG_OK: Incomplete
FMTFUNC_PRINTF: Incomplete
FMTFUNC_SCANF: Incomplete
FMTFUNC_STRFTIME: Incomplete
FMTFUNC_STRFMON: Incomplete

class stkarg_area_info_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    cb: Incomplete
    stkarg_offset: Incomplete
    shadow_size: Incomplete
    linkage_area: Incomplete
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class edm_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    name: Incomplete
    cmt: Incomplete
    value: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def swap(self, *args) -> None: ...
    def get_tid(self, *args) -> tid_t: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class enum_type_data_t(edmvec_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    group_sizes: Incomplete
    taenum_bits: Incomplete
    bte: Incomplete
    def __init__(self, *args) -> None: ...
    def get_enum_radix(self, *args) -> int: ...
    def is_number_signed(self, *args) -> bool: ...
    def set_enum_radix(self, *args) -> None: ...
    def is_char(self, *args) -> bool: ...
    def is_dec(self, *args) -> bool: ...
    def is_hex(self, *args) -> bool: ...
    def is_oct(self, *args) -> bool: ...
    def is_bin(self, *args) -> bool: ...
    def is_udec(self, *args) -> bool: ...
    def is_shex(self, *args) -> bool: ...
    def is_soct(self, *args) -> bool: ...
    def is_sbin(self, *args) -> bool: ...
    def has_lzero(self, *args) -> bool: ...
    def set_lzero(self, *args) -> None: ...
    def calc_mask(self, *args) -> uint64: ...
    def store_64bit_values(self, *args) -> bool: ...
    def is_bf(self, *args) -> bool: ...
    def calc_nbytes(self, *args) -> int: ...
    def set_nbytes(self, *args) -> bool: ...
    def get_constant_group(self, *args) -> bool: ...
    def is_group_mask_at(self, *args) -> bool: ...
    def is_valid_group_sizes(self, *args) -> bool: ...
    def find_member(self, *args) -> ssize_t: ...
    def swap(self, *args) -> None: ...
    def add_constant(self, *args) -> None: ...
    def set_value_repr(self, *args) -> tinfo_code_t: ...
    __swig_destroy__: Incomplete

class typedef_type_data_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    til: Incomplete
    name: Incomplete
    ordinal: Incomplete
    is_ordref: Incomplete
    resolve: Incomplete
    def __init__(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class custom_data_type_info_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    dtid: Incomplete
    fid: Incomplete
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class value_repr_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    bits: Incomplete
    ri: Incomplete
    strtype: Incomplete
    delta: Incomplete
    type_ordinal: Incomplete
    cd: Incomplete
    ap: Incomplete
    def swap(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def empty(self, *args) -> bool: ...
    def is_enum(self, *args) -> bool: ...
    def is_offset(self, *args) -> bool: ...
    def is_strlit(self, *args) -> bool: ...
    def is_custom(self, *args) -> bool: ...
    def is_stroff(self, *args) -> bool: ...
    def is_typref(self, *args) -> bool: ...
    def is_signed(self, *args) -> bool: ...
    def has_tabform(self, *args) -> bool: ...
    def has_lzeroes(self, *args) -> bool: ...
    def get_vtype(self, *args) -> uint64: ...
    def set_vtype(self, *args) -> None: ...
    def set_signed(self, *args) -> None: ...
    def set_tabform(self, *args) -> None: ...
    def set_lzeroes(self, *args) -> None: ...
    def set_ap(self, *args) -> None: ...
    def init_ap(self, *args) -> None: ...
    def from_opinfo(self, *args) -> bool: ...
    def _print(self, *args) -> size_t: ...
    def parse_value_repr(self, *args) -> bool: ...
    def __str__(self, *args) -> qstring: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

FRB_MASK: Incomplete
FRB_UNK: Incomplete
FRB_NUMB: Incomplete
FRB_NUMO: Incomplete
FRB_NUMH: Incomplete
FRB_NUMD: Incomplete
FRB_FLOAT: Incomplete
FRB_CHAR: Incomplete
FRB_SEG: Incomplete
FRB_ENUM: Incomplete
FRB_OFFSET: Incomplete
FRB_STRLIT: Incomplete
FRB_STROFF: Incomplete
FRB_CUSTOM: Incomplete
FRB_INVSIGN: Incomplete
FRB_INVBITS: Incomplete
FRB_SIGNED: Incomplete
FRB_LZERO: Incomplete
FRB_TABFORM: Incomplete

class udm_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    offset: Incomplete
    size: Incomplete
    name: Incomplete
    cmt: Incomplete
    type: Incomplete
    repr: Incomplete
    effalign: Incomplete
    tafld_bits: Incomplete
    fda: Incomplete
    def is_bitfield(self, *args) -> bool: ...
    def is_zero_bitfield(self, *args) -> bool: ...
    def is_unaligned(self, *args) -> bool: ...
    def is_baseclass(self, *args) -> bool: ...
    def is_virtbase(self, *args) -> bool: ...
    def is_vftable(self, *args) -> bool: ...
    def is_method(self, *args) -> bool: ...
    def is_gap(self, *args) -> bool: ...
    def is_regcmt(self, *args) -> bool: ...
    def set_unaligned(self, *args) -> None: ...
    def set_baseclass(self, *args) -> None: ...
    def set_virtbase(self, *args) -> None: ...
    def set_vftable(self, *args) -> None: ...
    def set_method(self, *args) -> None: ...
    def set_regcmt(self, *args) -> None: ...
    def clr_unaligned(self, *args) -> None: ...
    def clr_baseclass(self, *args) -> None: ...
    def clr_virtbase(self, *args) -> None: ...
    def clr_vftable(self, *args) -> None: ...
    def clr_method(self, *args) -> None: ...
    def begin(self, *args) -> uint64: ...
    def end(self, *args) -> uint64: ...
    def __lt__(self, *args) -> bool: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def swap(self, *args) -> None: ...
    def is_anonymous_udm(self, *args) -> bool: ...
    def make_gap(self, *args) -> bool: ...
    def set_value_repr(self, *args) -> None: ...
    def can_be_dtor(self, *args) -> bool: ...
    def can_rename(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class udtmembervec_t(udtmembervec_template_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class udt_type_data_t(udtmembervec_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    total_size: Incomplete
    unpadded_size: Incomplete
    effalign: Incomplete
    taudt_bits: Incomplete
    version: Incomplete
    sda: Incomplete
    pack: Incomplete
    is_union: Incomplete
    def swap(self, *args) -> None: ...
    def is_unaligned(self, *args) -> bool: ...
    def is_msstruct(self, *args) -> bool: ...
    def is_cppobj(self, *args) -> bool: ...
    def is_vftable(self, *args) -> bool: ...
    def set_vftable(self, *args) -> None: ...
    def is_last_baseclass(self, *args) -> bool: ...
    def find_member(self, *args) -> ssize_t: ...
    def get_best_fit_member(self, *args) -> ssize_t: ...
    __swig_destroy__: Incomplete
    def __init__(self, *args) -> None: ...

VTBL_SUFFIX: Incomplete
VTBL_MEMNAME: Incomplete

class bitfield_type_data_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    nbytes: Incomplete
    width: Incomplete
    is_unsigned: Incomplete
    def __init__(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def swap(self, *args) -> None: ...
    def is_valid_bitfield(self, *args) -> bool: ...
    __swig_destroy__: Incomplete

TPOS_LNNUM: Incomplete
TPOS_REGCMT: Incomplete

def inf_pack_stkargs(*args) -> bool: ...
def inf_big_arg_align(*args) -> bool: ...
def inf_huge_arg_align(*args) -> bool: ...

class type_mods_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    type: Incomplete
    name: Incomplete
    cmt: Incomplete
    flags: Incomplete
    def clear(self, *args) -> None: ...
    def set_new_type(self, *args) -> None: ...
    def set_new_name(self, *args) -> None: ...
    def set_new_cmt(self, *args) -> None: ...
    def has_type(self, *args) -> bool: ...
    def has_name(self, *args) -> bool: ...
    def has_cmt(self, *args) -> bool: ...
    def is_rptcmt(self, *args) -> bool: ...
    def has_info(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

TVIS_TYPE: Incomplete
TVIS_NAME: Incomplete
TVIS_CMT: Incomplete
TVIS_RPTCMT: Incomplete

class tinfo_visitor_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    state: Incomplete
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def visit_type(self, *args) -> int: ...
    def prune_now(self, *args) -> None: ...
    def apply_to(self, *args) -> int: ...
    def __disown__(self): ...

TVST_PRUNE: Incomplete
TVST_DEF: Incomplete
TVST_LEVEL: Incomplete

class regobj_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    regidx: Incomplete
    relocate: Incomplete
    value: Incomplete
    def size(self, *args) -> size_t: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class regobjs_t(regobjvec_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

def unpack_idcobj_from_idb(*args) -> error_t: ...

PIO_NOATTR_FAIL: Incomplete
PIO_IGNORE_PTRS: Incomplete

def unpack_idcobj_from_bv(*args) -> error_t: ...
def pack_idcobj_to_idb(*args) -> error_t: ...
def pack_idcobj_to_bv(*args) -> error_t: ...
def apply_tinfo_to_stkarg(*args) -> bool: ...

class argtinfo_helper_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    reserved: Incomplete
    __swig_destroy__: Incomplete
    def set_op_tinfo(self, *args) -> bool: ...
    def is_stkarg_load(self, *args) -> bool: ...
    def has_delay_slot(self, *args) -> bool: ...
    def use_arg_tinfos(self, *args) -> None: ...
    def __init__(self, *args) -> None: ...
    def __disown__(self): ...

def gen_use_arg_tinfos2(*args) -> None: ...
def func_has_stkframe_hole(*args) -> bool: ...

class lowertype_helper_t:
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __repr__ = _swig_repr
    def func_has_stkframe_hole(self, *args) -> bool: ...
    def get_func_purged_bytes(self, *args) -> int: ...
    __swig_destroy__: Incomplete

class ida_lowertype_helper_t(lowertype_helper_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    def func_has_stkframe_hole(self, *args) -> bool: ...
    def get_func_purged_bytes(self, *args) -> int: ...
    __swig_destroy__: Incomplete

def lower_type(*args) -> int: ...
def replace_ordinal_typerefs(*args) -> int: ...

UTP_ENUM: Incomplete
UTP_STRUCT: Incomplete

def begin_type_updating(*args) -> None: ...
def end_type_updating(*args) -> None: ...
def get_named_type_tid(*args) -> tid_t: ...
def get_tid_name(*args) -> 'qstring *': ...
def get_tid_ordinal(*args) -> uint32: ...
def get_udm_by_fullname(*args) -> ssize_t: ...
def create_enum_type(*args) -> tid_t: ...

class valstr_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    oneline: Incomplete
    length: Incomplete
    members: Incomplete
    info: Incomplete
    props: Incomplete
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

VALSTR_OPEN: Incomplete

class valstrs_t(valstrvec_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class text_sink_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def _print(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def __disown__(self): ...

PDF_INCL_DEPS: Incomplete
PDF_DEF_FWD: Incomplete
PDF_DEF_BASE: Incomplete
PDF_HEADER_CMT: Incomplete

def calc_number_of_children(*args) -> int: ...
def get_enum_member_expr(*args) -> 'qstring *': ...

class til_symbol_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    name: Incomplete
    til: Incomplete
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class predicate_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def should_display(self, *args) -> bool: ...
    __swig_destroy__: Incomplete
    def __init__(self, *args) -> None: ...
    def __disown__(self): ...

def choose_named_type(*args) -> bool: ...
def choose_local_tinfo(*args) -> uint32: ...
def choose_local_tinfo_and_delta(*args) -> uint32: ...
def gen_use_arg_tinfos(*args) -> None: ...
def create_tinfo(*args) -> bool: ...
def get_tinfo_details(*args) -> bool: ...
def get_ordinal_qty(*args) -> uint32: ...
def idc_parse_decl(*args) -> 'PyObject *': ...
def calc_type_size(*args) -> 'PyObject *': ...
def apply_type(*args) -> bool: ...
def get_arg_addrs(*args) -> 'PyObject *': ...
def unpack_object_from_idb(*args) -> 'PyObject *': ...
def unpack_object_from_bv(*args) -> 'PyObject *': ...
def pack_object_to_idb(*args) -> 'PyObject *': ...
def pack_object_to_bv(*args) -> 'PyObject *': ...

PT_FILE: Incomplete

def idc_parse_types(*args) -> int: ...
def idc_get_type_raw(*args) -> 'PyObject *': ...
def idc_get_local_type_raw(*args) -> 'PyObject *': ...
def idc_guess_type(*args) -> size_t: ...
def idc_get_type(*args) -> size_t: ...
def idc_set_local_type(*args) -> int: ...
def idc_get_local_type(*args) -> size_t: ...
def idc_print_type(*args) -> 'PyObject *': ...
def idc_get_local_type_name(*args) -> size_t: ...
def get_named_type(*args) -> 'PyObject *': ...
def get_named_type64(*args) -> 'PyObject *': ...
def print_decls(*args) -> 'PyObject *': ...
def remove_tinfo_pointer(*args) -> 'PyObject *': ...
def get_numbered_type(*args) -> 'PyObject *': ...
_real_cvar = cvar
_notify_idati: Incomplete

class _wrap_cvar:
    def __getattr__(self, attr): ...
    def __setattr__(self, attr, value) -> None: ...
sc_auto = SC_AUTO
sc_ext = SC_EXT
sc_friend = SC_FRIEND
sc_reg = SC_REG
sc_stat = SC_STAT
sc_type = SC_TYPE
sc_unk = SC_UNK
sc_virt = SC_VIRT
TERR_SAVE = TERR_SAVE_ERROR
TERR_WRONGNAME = TERR_BAD_NAME
TERR_BADSYNC = TERR_BAD_SYNC
BADORD: int
enum_member_vec_t = edmvec_t
enum_member_t = edm_t
udt_member_t = udm_t
IMPTYPE_VERBOSE: int
IMPTYPE_OVERRIDE: int
