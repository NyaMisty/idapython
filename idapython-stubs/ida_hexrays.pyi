# mypy: disable-error-code="valid-type, name-defined, no-redef, assignment, misc, override"

import ida_gdl
import ida_idaapi
import ida_pro
import ida_typeinf
from _typeshed import Incomplete
from collections.abc import Generator

def _swig_repr(self): ...
def _swig_setattr_nondynamic_instance_variable(set): ...
def _swig_setattr_nondynamic_class_variable(set): ...
def _swig_add_metaclass(metaclass): ...

class _SwigNonDynamicMeta(type):
    __setattr__: Incomplete

SWIG_PYTHON_LEGACY_BOOL: Incomplete

def _kludge_force_declare_TPopupMenu(*args) -> None: ...

class array_of_bitsets:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'bitset_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'bitset_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'bitset_t *': ...
    def inject(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'qvector< bitset_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< bitset_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< bitset_t >::iterator': ...
    def erase(self, *args) -> 'qvector< bitset_t >::iterator': ...
    def find(self, *args) -> 'qvector< bitset_t >::const_iterator': ...
    def has(self, *args) -> bool: ...
    def add_unique(self, *args) -> bool: ...
    def _del(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'bitset_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class mopvec_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'mop_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'mop_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'mop_t *': ...
    def inject(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'qvector< mop_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< mop_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< mop_t >::iterator': ...
    def erase(self, *args) -> 'qvector< mop_t >::iterator': ...
    def find(self, *args) -> 'qvector< mop_t >::const_iterator': ...
    def has(self, *args) -> bool: ...
    def add_unique(self, *args) -> bool: ...
    def _del(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'mop_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class mcallargs_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'mcallarg_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'mcallarg_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'mcallarg_t *': ...
    def inject(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'qvector< mcallarg_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< mcallarg_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< mcallarg_t >::iterator': ...
    def erase(self, *args) -> 'qvector< mcallarg_t >::iterator': ...
    def find(self, *args) -> 'qvector< mcallarg_t >::const_iterator': ...
    def has(self, *args) -> bool: ...
    def add_unique(self, *args) -> bool: ...
    def _del(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'mcallarg_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class block_chains_vec_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'block_chains_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'block_chains_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'block_chains_t *': ...
    def inject(self, *args) -> None: ...
    def begin(self, *args) -> 'qvector< block_chains_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< block_chains_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< block_chains_t >::iterator': ...
    def erase(self, *args) -> 'qvector< block_chains_t >::iterator': ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'block_chains_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class user_numforms_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def at(self, *args) -> 'number_format_t &': ...
    def size(self, *args) -> size_t: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class lvar_mapping_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def at(self, *args) -> 'lvar_locator_t &': ...
    def size(self, *args) -> size_t: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class hexwarns_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'hexwarn_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'hexwarn_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'hexwarn_t *': ...
    def inject(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'qvector< hexwarn_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< hexwarn_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< hexwarn_t >::iterator': ...
    def erase(self, *args) -> 'qvector< hexwarn_t >::iterator': ...
    def find(self, *args) -> 'qvector< hexwarn_t >::const_iterator': ...
    def has(self, *args) -> bool: ...
    def add_unique(self, *args) -> bool: ...
    def _del(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'hexwarn_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class ctree_items_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'citem_t *&': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'citem_t *const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'citem_t **': ...
    def inject(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'qvector< citem_t * >::const_iterator': ...
    def end(self, *args) -> 'qvector< citem_t * >::const_iterator': ...
    def insert(self, *args) -> 'qvector< citem_t * >::iterator': ...
    def erase(self, *args) -> 'qvector< citem_t * >::iterator': ...
    def find(self, *args) -> 'qvector< citem_t * >::const_iterator': ...
    def has(self, *args) -> bool: ...
    def add_unique(self, *args) -> bool: ...
    def _del(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'citem_t *const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class user_labels_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def at(self, *args) -> '_qstring< char > &': ...
    def size(self, *args) -> size_t: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class user_cmts_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def at(self, *args) -> 'citem_cmt_t &': ...
    def size(self, *args) -> size_t: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class user_iflags_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def at(self, *args) -> 'int &': ...
    def size(self, *args) -> size_t: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class user_unions_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def at(self, *args) -> 'qvector< int > &': ...
    def size(self, *args) -> size_t: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class cinsnptrvec_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'cinsn_t *&': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'cinsn_t *const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'cinsn_t **': ...
    def inject(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'qvector< cinsn_t * >::const_iterator': ...
    def end(self, *args) -> 'qvector< cinsn_t * >::const_iterator': ...
    def insert(self, *args) -> 'qvector< cinsn_t * >::iterator': ...
    def erase(self, *args) -> 'qvector< cinsn_t * >::iterator': ...
    def find(self, *args) -> 'qvector< cinsn_t * >::const_iterator': ...
    def has(self, *args) -> bool: ...
    def add_unique(self, *args) -> bool: ...
    def _del(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'cinsn_t *const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class eamap_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def at(self, *args) -> 'cinsnptrvec_t &': ...
    def size(self, *args) -> size_t: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class boundaries_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def at(self, *args) -> 'rangeset_t &': ...
    def size(self, *args) -> size_t: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

def user_iflags_second(*args) -> 'int32 const &': ...

class cfuncptr_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    def reset(self, *args) -> None: ...
    def __deref__(self, *args) -> 'cfunc_t *': ...
    def __ref__(self, *args) -> 'cfunc_t &': ...
    def __ptrval__(self, *args) -> size_t: ...
    __swig_destroy__: Incomplete
    entry_ea: Incomplete
    mba: Incomplete
    body: Incomplete
    argidx: Incomplete
    maturity: Incomplete
    user_labels: Incomplete
    user_cmts: Incomplete
    numforms: Incomplete
    user_iflags: Incomplete
    user_unions: Incomplete
    refcnt: Incomplete
    statebits: Incomplete
    hdrlines: Incomplete
    treeitems: Incomplete
    def release(self, *args) -> None: ...
    def build_c_tree(self, *args) -> None: ...
    def verify(self, *args) -> None: ...
    def print_dcl(self, *args) -> None: ...
    def print_func(self, *args) -> None: ...
    def get_func_type(self, *args) -> bool: ...
    def get_lvars(self, *args) -> 'lvars_t *': ...
    def get_stkoff_delta(self, *args) -> sval_t: ...
    def find_label(self, *args) -> 'citem_t *': ...
    def remove_unused_labels(self, *args) -> None: ...
    def get_user_cmt(self, *args) -> 'char const *': ...
    def set_user_cmt(self, *args) -> None: ...
    def get_user_iflags(self, *args) -> int32: ...
    def set_user_iflags(self, *args) -> None: ...
    def has_orphan_cmts(self, *args) -> bool: ...
    def del_orphan_cmts(self, *args) -> int: ...
    def get_user_union_selection(self, *args) -> bool: ...
    def set_user_union_selection(self, *args) -> None: ...
    def save_user_labels(self, *args) -> None: ...
    def save_user_cmts(self, *args) -> None: ...
    def save_user_numforms(self, *args) -> None: ...
    def save_user_iflags(self, *args) -> None: ...
    def save_user_unions(self, *args) -> None: ...
    def get_line_item(self, *args) -> bool: ...
    def get_warnings(self, *args) -> 'hexwarns_t &': ...
    def get_eamap(self, *args) -> 'eamap_t &': ...
    def get_boundaries(self, *args) -> 'boundaries_t &': ...
    def get_pseudocode(self, *args) -> 'strvec_t const &': ...
    def refresh_func_ctext(self, *args) -> None: ...
    def gather_derefs(self, *args) -> bool: ...
    def find_item_coords(self, *args) -> 'PyObject *': ...
    def locked(self, *args) -> bool: ...
    def __str__(self, *args) -> qstring: ...

class qvector_history_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'history_item_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'history_item_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'history_item_t *': ...
    def inject(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'qvector< history_item_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< history_item_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< history_item_t >::iterator': ...
    def erase(self, *args) -> 'qvector< history_item_t >::iterator': ...
    def find(self, *args) -> 'qvector< history_item_t >::const_iterator': ...
    def has(self, *args) -> bool: ...
    def add_unique(self, *args) -> bool: ...
    def _del(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'history_item_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class history_t(qvector_history_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def pop(self, *args) -> history_item_t: ...
    def top(self, *args) -> 'history_item_t &': ...
    def push(self, *args) -> None: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class cinsn_list_t_iterator:
    thisown: Incomplete
    __repr__ = _swig_repr
    cur: Incomplete
    def __next__(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    next = __next__
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class cinsn_list_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def swap(self, *args) -> None: ...
    def empty(self, *args) -> bool: ...
    def size(self, *args) -> size_t: ...
    def front(self, *args) -> 'cinsn_t const &': ...
    def back(self, *args) -> 'cinsn_t const &': ...
    def rbegin(self, *args) -> 'qlist< cinsn_t >::const_reverse_iterator': ...
    def rend(self, *args) -> 'qlist< cinsn_t >::const_reverse_iterator': ...
    def push_front(self, *args) -> None: ...
    def push_back(self, *args) -> 'cinsn_t &': ...
    def clear(self, *args) -> None: ...
    def pop_front(self, *args) -> None: ...
    def pop_back(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'cinsn_t const &': ...
    def __setitem__(self, *args) -> None: ...
    def remove(self, *args) -> bool: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator
    def find(self, item): ...
    def index(self, item): ...
    def at(self, index): ...
    def begin(self, *args) -> cinsn_list_t_iterator: ...
    def end(self, *args) -> cinsn_list_t_iterator: ...
    def insert(self, *args) -> cinsn_list_t_iterator: ...
    def erase(self, *args) -> None: ...

class qvector_lvar_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'lvar_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'lvar_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'lvar_t *': ...
    def inject(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'qvector< lvar_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< lvar_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< lvar_t >::iterator': ...
    def erase(self, *args) -> 'qvector< lvar_t >::iterator': ...
    def find(self, *args) -> 'qvector< lvar_t >::const_iterator': ...
    def has(self, *args) -> bool: ...
    def add_unique(self, *args) -> bool: ...
    def _del(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'lvar_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class qvector_carg_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'carg_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'carg_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'carg_t *': ...
    def inject(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'qvector< carg_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< carg_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< carg_t >::iterator': ...
    def erase(self, *args) -> 'qvector< carg_t >::iterator': ...
    def find(self, *args) -> 'qvector< carg_t >::const_iterator': ...
    def has(self, *args) -> bool: ...
    def add_unique(self, *args) -> bool: ...
    def _del(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'carg_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class qvector_ccase_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'ccase_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'ccase_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'ccase_t *': ...
    def inject(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'qvector< ccase_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< ccase_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< ccase_t >::iterator': ...
    def erase(self, *args) -> 'qvector< ccase_t >::iterator': ...
    def find(self, *args) -> 'qvector< ccase_t >::const_iterator': ...
    def has(self, *args) -> bool: ...
    def add_unique(self, *args) -> bool: ...
    def _del(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'ccase_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class lvar_saved_infos_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'lvar_saved_info_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'lvar_saved_info_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'lvar_saved_info_t *': ...
    def inject(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'qvector< lvar_saved_info_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< lvar_saved_info_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< lvar_saved_info_t >::iterator': ...
    def erase(self, *args) -> 'qvector< lvar_saved_info_t >::iterator': ...
    def find(self, *args) -> 'qvector< lvar_saved_info_t >::const_iterator': ...
    def has(self, *args) -> bool: ...
    def add_unique(self, *args) -> bool: ...
    def _del(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'lvar_saved_info_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

class ui_stroff_ops_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'ui_stroff_op_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'ui_stroff_op_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'ui_stroff_op_t *': ...
    def inject(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'qvector< ui_stroff_op_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< ui_stroff_op_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< ui_stroff_op_t >::iterator': ...
    def erase(self, *args) -> 'qvector< ui_stroff_op_t >::iterator': ...
    def find(self, *args) -> 'qvector< ui_stroff_op_t >::const_iterator': ...
    def has(self, *args) -> bool: ...
    def add_unique(self, *args) -> bool: ...
    def _del(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'ui_stroff_op_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

def qswap(*args) -> None: ...
def debug_hexrays_ctree(*args) -> None: ...
def init_hexrays_plugin(*args) -> bool: ...
def get_widget_vdui(*args) -> 'vdui_t *': ...
def boundaries_find(*args) -> boundaries_iterator_t: ...
def boundaries_insert(*args) -> boundaries_iterator_t: ...
def term_hexrays_plugin(*args) -> None: ...

class Hexrays_Hooks:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def hook(self, *args) -> bool: ...
    def unhook(self, *args) -> bool: ...
    def flowchart(self, *args) -> int: ...
    def stkpnts(self, *args) -> int: ...
    def prolog(self, *args) -> int: ...
    def microcode(self, *args) -> int: ...
    def preoptimized(self, *args) -> int: ...
    def locopt(self, *args) -> int: ...
    def prealloc(self, *args) -> int: ...
    def glbopt(self, *args) -> int: ...
    def structural(self, *args) -> int: ...
    def maturity(self, *args) -> int: ...
    def interr(self, *args) -> int: ...
    def combine(self, *args) -> int: ...
    def print_func(self, *args) -> int: ...
    def func_printed(self, *args) -> int: ...
    def resolve_stkaddrs(self, *args) -> int: ...
    def build_callinfo(self, *args) -> 'PyObject *': ...
    def callinfo_built(self, *args) -> int: ...
    def calls_done(self, *args) -> int: ...
    def open_pseudocode(self, *args) -> int: ...
    def switch_pseudocode(self, *args) -> int: ...
    def refresh_pseudocode(self, *args) -> int: ...
    def close_pseudocode(self, *args) -> int: ...
    def keyboard(self, *args) -> int: ...
    def right_click(self, *args) -> int: ...
    def double_click(self, *args) -> int: ...
    def curpos(self, *args) -> int: ...
    def create_hint(self, *args) -> 'PyObject *': ...
    def text_ready(self, *args) -> int: ...
    def populating_popup(self, *args) -> int: ...
    def lvar_name_changed(self, *args) -> int: ...
    def lvar_type_changed(self, *args) -> int: ...
    def lvar_cmt_changed(self, *args) -> int: ...
    def lvar_mapping_changed(self, *args) -> int: ...
    def cmt_changed(self, *args) -> int: ...
    def __disown__(self): ...

class uval_ivl_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    off: Incomplete
    size: Incomplete
    def __init__(self, *args) -> None: ...
    def valid(self, *args) -> bool: ...
    def end(self, *args) -> 'unsigned long long': ...
    def last(self, *args) -> 'unsigned long long': ...
    __swig_destroy__: Incomplete

class uval_ivl_ivlset_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def getivl(self, *args) -> 'ivl_t const &': ...
    def lastivl(self, *args) -> 'ivl_t const &': ...
    def nivls(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def clear(self, *args) -> None: ...
    def qclear(self, *args) -> None: ...
    def all_values(self, *args) -> bool: ...
    def set_all_values(self, *args) -> None: ...
    def single_value(self, *args) -> bool: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'ivlset_tpl< ivl_t,unsigned long long >::iterator': ...
    def end(self, *args) -> 'ivlset_tpl< ivl_t,unsigned long long >::iterator': ...
    __swig_destroy__: Incomplete

class array_of_ivlsets:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def push_back(self, *args) -> 'ivlset_t &': ...
    def pop_back(self, *args) -> None: ...
    def size(self, *args) -> size_t: ...
    def empty(self, *args) -> bool: ...
    def at(self, *args) -> 'ivlset_t const &': ...
    def qclear(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def resize(self, *args) -> None: ...
    def grow(self, *args) -> None: ...
    def capacity(self, *args) -> size_t: ...
    def reserve(self, *args) -> None: ...
    def truncate(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def extract(self, *args) -> 'ivlset_t *': ...
    def inject(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def begin(self, *args) -> 'qvector< ivlset_t >::const_iterator': ...
    def end(self, *args) -> 'qvector< ivlset_t >::const_iterator': ...
    def insert(self, *args) -> 'qvector< ivlset_t >::iterator': ...
    def erase(self, *args) -> 'qvector< ivlset_t >::iterator': ...
    def find(self, *args) -> 'qvector< ivlset_t >::const_iterator': ...
    def has(self, *args) -> bool: ...
    def add_unique(self, *args) -> bool: ...
    def _del(self, *args) -> bool: ...
    def __len__(self, *args) -> size_t: ...
    def __getitem__(self, *args) -> 'ivlset_t const &': ...
    def __setitem__(self, *args) -> None: ...
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

MAX_SUPPORTED_STACK_SIZE: Incomplete

def hexrays_alloc(*args) -> 'void *': ...
def hexrays_free(*args) -> None: ...

MAX_VLR_SIZE: Incomplete
CMP_NZ: Incomplete
CMP_Z: Incomplete
CMP_AE: Incomplete
CMP_B: Incomplete
CMP_A: Incomplete
CMP_BE: Incomplete
CMP_GT: Incomplete
CMP_GE: Incomplete
CMP_LT: Incomplete
CMP_LE: Incomplete

class valrng_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def swap(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def set_none(self, *args) -> None: ...
    def set_all(self, *args) -> None: ...
    def set_unk(self, *args) -> None: ...
    def set_eq(self, *args) -> None: ...
    def set_cmp(self, *args) -> None: ...
    def reduce_size(self, *args) -> bool: ...
    def intersect_with(self, *args) -> bool: ...
    def unite_with(self, *args) -> bool: ...
    def inverse(self, *args) -> None: ...
    def empty(self, *args) -> bool: ...
    def all_values(self, *args) -> bool: ...
    def is_unknown(self, *args) -> bool: ...
    def has(self, *args) -> bool: ...
    def _print(self, *args) -> None: ...
    def dstr(self, *args) -> 'char const *': ...
    def cvt_to_single_value(self, *args) -> bool: ...
    def cvt_to_cmp(self, *args) -> bool: ...
    def get_size(self, *args) -> int: ...
    def max_value(self, *args) -> uvlr_t: ...
    def min_svalue(self, *args) -> uvlr_t: ...
    def max_svalue(self, *args) -> uvlr_t: ...
    def _register(self, *args) -> None: ...
    def _deregister(self, *args) -> None: ...

cvar: Incomplete
MAX_VALUE: Incomplete
MAX_SVALUE: Incomplete
MIN_SVALUE: Incomplete

def is_may_access(*args) -> bool: ...

MERR_OK: Incomplete
MERR_BLOCK: Incomplete
MERR_INTERR: Incomplete
MERR_INSN: Incomplete
MERR_MEM: Incomplete
MERR_BADBLK: Incomplete
MERR_BADSP: Incomplete
MERR_PROLOG: Incomplete
MERR_SWITCH: Incomplete
MERR_EXCEPTION: Incomplete
MERR_HUGESTACK: Incomplete
MERR_LVARS: Incomplete
MERR_BITNESS: Incomplete
MERR_BADCALL: Incomplete
MERR_BADFRAME: Incomplete
MERR_UNKTYPE: Incomplete
MERR_BADIDB: Incomplete
MERR_SIZEOF: Incomplete
MERR_REDO: Incomplete
MERR_CANCELED: Incomplete
MERR_RECDEPTH: Incomplete
MERR_OVERLAP: Incomplete
MERR_PARTINIT: Incomplete
MERR_COMPLEX: Incomplete
MERR_LICENSE: Incomplete
MERR_ONLY32: Incomplete
MERR_ONLY64: Incomplete
MERR_BUSY: Incomplete
MERR_FARPTR: Incomplete
MERR_EXTERN: Incomplete
MERR_FUNCSIZE: Incomplete
MERR_BADRANGES: Incomplete
MERR_BADARCH: Incomplete
MERR_DSLOT: Incomplete
MERR_STOP: Incomplete
MERR_CLOUD: Incomplete
MERR_MAX_ERR: Incomplete
MERR_LOOP: Incomplete

def get_merror_desc(*args) -> 'qstring *': ...

m_nop: Incomplete
m_stx: Incomplete
m_ldx: Incomplete
m_ldc: Incomplete
m_mov: Incomplete
m_neg: Incomplete
m_lnot: Incomplete
m_bnot: Incomplete
m_xds: Incomplete
m_xdu: Incomplete
m_low: Incomplete
m_high: Incomplete
m_add: Incomplete
m_sub: Incomplete
m_mul: Incomplete
m_udiv: Incomplete
m_sdiv: Incomplete
m_umod: Incomplete
m_smod: Incomplete
m_or: Incomplete
m_and: Incomplete
m_xor: Incomplete
m_shl: Incomplete
m_shr: Incomplete
m_sar: Incomplete
m_cfadd: Incomplete
m_ofadd: Incomplete
m_cfshl: Incomplete
m_cfshr: Incomplete
m_sets: Incomplete
m_seto: Incomplete
m_setp: Incomplete
m_setnz: Incomplete
m_setz: Incomplete
m_setae: Incomplete
m_setb: Incomplete
m_seta: Incomplete
m_setbe: Incomplete
m_setg: Incomplete
m_setge: Incomplete
m_setl: Incomplete
m_setle: Incomplete
m_jcnd: Incomplete
m_jnz: Incomplete
m_jz: Incomplete
m_jae: Incomplete
m_jb: Incomplete
m_ja: Incomplete
m_jbe: Incomplete
m_jg: Incomplete
m_jge: Incomplete
m_jl: Incomplete
m_jle: Incomplete
m_jtbl: Incomplete
m_ijmp: Incomplete
m_goto: Incomplete
m_call: Incomplete
m_icall: Incomplete
m_ret: Incomplete
m_push: Incomplete
m_pop: Incomplete
m_und: Incomplete
m_ext: Incomplete
m_f2i: Incomplete
m_f2u: Incomplete
m_i2f: Incomplete
m_u2f: Incomplete
m_f2f: Incomplete
m_fneg: Incomplete
m_fadd: Incomplete
m_fsub: Incomplete
m_fmul: Incomplete
m_fdiv: Incomplete

def must_mcode_close_block(*args) -> bool: ...
def is_mcode_propagatable(*args) -> bool: ...
def is_mcode_addsub(*args) -> bool: ...
def is_mcode_xdsu(*args) -> bool: ...
def is_mcode_set(*args) -> bool: ...
def is_mcode_set1(*args) -> bool: ...
def is_mcode_j1(*args) -> bool: ...
def is_mcode_jcond(*args) -> bool: ...
def is_mcode_convertible_to_jmp(*args) -> bool: ...
def is_mcode_convertible_to_set(*args) -> bool: ...
def is_mcode_call(*args) -> bool: ...
def is_mcode_fpu(*args) -> bool: ...
def is_mcode_commutative(*args) -> bool: ...
def is_mcode_shift(*args) -> bool: ...
def is_mcode_divmod(*args) -> bool: ...
def has_mcode_seloff(*args) -> bool: ...
def set2jcnd(*args) -> mcode_t: ...
def jcnd2set(*args) -> mcode_t: ...
def negate_mcode_relation(*args) -> mcode_t: ...
def swap_mcode_relation(*args) -> mcode_t: ...
def get_signed_mcode(*args) -> mcode_t: ...
def get_unsigned_mcode(*args) -> mcode_t: ...
def is_signed_mcode(*args) -> bool: ...
def is_unsigned_mcode(*args) -> bool: ...
def mcode_modifies_d(*args) -> bool: ...

class operand_locator_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    ea: Incomplete
    opnum: Incomplete
    def __init__(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    __swig_destroy__: Incomplete

MUST_ACCESS: Incomplete
MAY_ACCESS: Incomplete
MAYMUST_ACCESS_MASK: Incomplete
ONE_ACCESS_TYPE: Incomplete
INCLUDE_SPOILED_REGS: Incomplete
EXCLUDE_PASS_REGS: Incomplete
FULL_XDSU: Incomplete
WITH_ASSERTS: Incomplete
EXCLUDE_VOLATILE: Incomplete
INCLUDE_UNUSED_SRC: Incomplete
INCLUDE_DEAD_RETREGS: Incomplete
INCLUDE_RESTRICTED: Incomplete
CALL_SPOILS_ONLY_ARGS: Incomplete
mr_none: Incomplete
mr_cf: Incomplete
mr_zf: Incomplete
mr_sf: Incomplete
mr_of: Incomplete
mr_pf: Incomplete
cc_count: Incomplete
mr_cc: Incomplete
mr_first: Incomplete

class number_format_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    flags32: Incomplete
    opnum: Incomplete
    props: Incomplete
    serial: Incomplete
    org_nbytes: Incomplete
    type_name: Incomplete
    flags: Incomplete
    def __init__(self, *args) -> None: ...
    def get_radix(self, *args) -> int: ...
    def is_fixed(self, *args) -> bool: ...
    def is_hex(self, *args) -> bool: ...
    def is_dec(self, *args) -> bool: ...
    def is_oct(self, *args) -> bool: ...
    def is_enum(self, *args) -> bool: ...
    def is_char(self, *args) -> bool: ...
    def is_stroff(self, *args) -> bool: ...
    def is_numop(self, *args) -> bool: ...
    def needs_to_be_inverted(self, *args) -> bool: ...
    def has_unmutable_type(self, *args) -> bool: ...
    __swig_destroy__: Incomplete

NF_FIXED: Incomplete
NF_NEGDONE: Incomplete
NF_BINVDONE: Incomplete
NF_NEGATE: Incomplete
NF_BITNOT: Incomplete
NF_VALID: Incomplete

class vd_printer_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    tmpbuf: Incomplete
    hdrlines: Incomplete
    def _print(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def __disown__(self): ...

class vc_printer_t(vd_printer_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    func: Incomplete
    lastchar: Incomplete
    def __init__(self, *args) -> None: ...
    def oneliner(self, *args) -> bool: ...
    __swig_destroy__: Incomplete
    def __disown__(self): ...

class qstring_printer_t(vc_printer_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    with_tags: Incomplete
    s: Incomplete
    def _print(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    def get_s(self, *args) -> qstring: ...

def dstr(*args) -> 'char const *': ...
def is_type_correct(*args) -> bool: ...
def is_small_udt(*args) -> bool: ...
def is_nonbool_type(*args) -> bool: ...
def is_bool_type(*args) -> bool: ...
def is_ptr_or_array(*args) -> bool: ...
def is_paf(*args) -> bool: ...
def is_inplace_def(*args) -> bool: ...
def partial_type_num(*args) -> int: ...
def get_float_type(*args) -> tinfo_t: ...
def get_int_type_by_width_and_sign(*args) -> tinfo_t: ...
def get_unk_type(*args) -> tinfo_t: ...
def dummy_ptrtype(*args) -> tinfo_t: ...
def get_member_type(*args) -> bool: ...
def make_pointer(*args) -> tinfo_t: ...
def create_typedef(*args) -> tinfo_t: ...

GUESSED_NONE: Incomplete
GUESSED_WEAK: Incomplete
GUESSED_FUNC: Incomplete
GUESSED_DATA: Incomplete
TS_NOELL: Incomplete
TS_SHRINK: Incomplete
TS_DONTREF: Incomplete
TS_MASK: Incomplete

def get_type(*args) -> bool: ...
def set_type(*args) -> bool: ...

class vdloc_t(ida_typeinf.argloc_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def reg1(self, *args) -> int: ...
    def _set_reg1(self, *args) -> None: ...
    def set_reg1(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def is_aliasable(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

def print_vdloc(*args) -> 'qstring *': ...
def arglocs_overlap(*args) -> bool: ...

class lvar_locator_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    location: Incomplete
    defea: Incomplete
    def __init__(self, *args) -> None: ...
    def get_stkoff(self, *args) -> sval_t: ...
    def is_reg1(self, *args) -> bool: ...
    def is_reg2(self, *args) -> bool: ...
    def is_reg_var(self, *args) -> bool: ...
    def is_stk_var(self, *args) -> bool: ...
    def is_scattered(self, *args) -> bool: ...
    def get_reg1(self, *args) -> mreg_t: ...
    def get_reg2(self, *args) -> mreg_t: ...
    def get_scattered(self, *args) -> 'scattered_aloc_t &': ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    __swig_destroy__: Incomplete

class lvar_t(lvar_locator_t):
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __repr__ = _swig_repr
    name: Incomplete
    cmt: Incomplete
    tif: Incomplete
    width: Incomplete
    defblk: Incomplete
    divisor: Incomplete
    def used(self, *args) -> bool: ...
    def typed(self, *args) -> bool: ...
    def mreg_done(self, *args) -> bool: ...
    def has_nice_name(self, *args) -> bool: ...
    def is_unknown_width(self, *args) -> bool: ...
    def has_user_info(self, *args) -> bool: ...
    def has_user_name(self, *args) -> bool: ...
    def has_user_type(self, *args) -> bool: ...
    def is_result_var(self, *args) -> bool: ...
    def is_arg_var(self, *args) -> bool: ...
    def is_fake_var(self, *args) -> bool: ...
    def is_overlapped_var(self, *args) -> bool: ...
    def is_floating_var(self, *args) -> bool: ...
    def is_spoiled_var(self, *args) -> bool: ...
    def is_noptr_var(self, *args) -> bool: ...
    def is_mapdst_var(self, *args) -> bool: ...
    def is_thisarg(self, *args) -> bool: ...
    def is_split_var(self, *args) -> bool: ...
    def has_regname(self, *args) -> bool: ...
    def in_asm(self, *args) -> bool: ...
    def is_dummy_arg(self, *args) -> bool: ...
    def is_notarg(self, *args) -> bool: ...
    def is_automapped(self, *args) -> bool: ...
    def is_used_byref(self, *args) -> bool: ...
    def is_decl_unused(self, *args) -> bool: ...
    def is_shared(self, *args) -> bool: ...
    def set_used(self, *args) -> None: ...
    def clear_used(self, *args) -> None: ...
    def set_typed(self, *args) -> None: ...
    def set_non_typed(self, *args) -> None: ...
    def clr_user_info(self, *args) -> None: ...
    def set_user_name(self, *args) -> None: ...
    def set_user_type(self, *args) -> None: ...
    def clr_user_type(self, *args) -> None: ...
    def clr_user_name(self, *args) -> None: ...
    def set_mreg_done(self, *args) -> None: ...
    def clr_mreg_done(self, *args) -> None: ...
    def set_unknown_width(self, *args) -> None: ...
    def clr_unknown_width(self, *args) -> None: ...
    def set_arg_var(self, *args) -> None: ...
    def clr_arg_var(self, *args) -> None: ...
    def set_fake_var(self, *args) -> None: ...
    def clr_fake_var(self, *args) -> None: ...
    def set_overlapped_var(self, *args) -> None: ...
    def clr_overlapped_var(self, *args) -> None: ...
    def set_floating_var(self, *args) -> None: ...
    def clr_floating_var(self, *args) -> None: ...
    def set_spoiled_var(self, *args) -> None: ...
    def clr_spoiled_var(self, *args) -> None: ...
    def set_mapdst_var(self, *args) -> None: ...
    def clr_mapdst_var(self, *args) -> None: ...
    def set_noptr_var(self, *args) -> None: ...
    def clr_noptr_var(self, *args) -> None: ...
    def set_thisarg(self, *args) -> None: ...
    def clr_thisarg(self, *args) -> None: ...
    def set_split_var(self, *args) -> None: ...
    def clr_split_var(self, *args) -> None: ...
    def set_dummy_arg(self, *args) -> None: ...
    def clr_dummy_arg(self, *args) -> None: ...
    def set_notarg(self, *args) -> None: ...
    def clr_notarg(self, *args) -> None: ...
    def set_automapped(self, *args) -> None: ...
    def clr_automapped(self, *args) -> None: ...
    def set_used_byref(self, *args) -> None: ...
    def clr_used_byref(self, *args) -> None: ...
    def set_decl_unused(self, *args) -> None: ...
    def clr_decl_unused(self, *args) -> None: ...
    def set_shared(self, *args) -> None: ...
    def clr_shared(self, *args) -> None: ...
    def has_common(self, *args) -> bool: ...
    def has_common_bit(self, *args) -> bool: ...
    def type(self, *args) -> 'tinfo_t &': ...
    def accepts_type(self, *args) -> bool: ...
    def set_lvar_type(self, *args) -> bool: ...
    def set_final_lvar_type(self, *args) -> None: ...
    def set_width(self, *args) -> bool: ...
    def append_list(self, *args) -> None: ...
    def is_aliasable(self, *args) -> bool: ...
    __swig_destroy__: Incomplete

SVW_INT: Incomplete
SVW_FLOAT: Incomplete
SVW_SOFT: Incomplete

class lvars_t(qvector_lvar_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def find_input_lvar(self, *args) -> int: ...
    def find_stkvar(self, *args) -> int: ...
    def find(self, *args) -> 'lvar_t *': ...
    def find_lvar(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class lvar_saved_info_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    ll: Incomplete
    name: Incomplete
    type: Incomplete
    cmt: Incomplete
    size: Incomplete
    flags: Incomplete
    def has_info(self, *args) -> bool: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def is_kept(self, *args) -> bool: ...
    def clear_keep(self, *args) -> None: ...
    def set_keep(self, *args) -> None: ...
    def is_split_lvar(self, *args) -> bool: ...
    def set_split_lvar(self, *args) -> None: ...
    def clr_split_lvar(self, *args) -> None: ...
    def is_noptr_lvar(self, *args) -> bool: ...
    def set_noptr_lvar(self, *args) -> None: ...
    def clr_noptr_lvar(self, *args) -> None: ...
    def is_nomap_lvar(self, *args) -> bool: ...
    def set_nomap_lvar(self, *args) -> None: ...
    def clr_nomap_lvar(self, *args) -> None: ...
    def is_unused_lvar(self, *args) -> bool: ...
    def set_unused_lvar(self, *args) -> None: ...
    def clr_unused_lvar(self, *args) -> None: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

LVINF_KEEP: Incomplete
LVINF_SPLIT: Incomplete
LVINF_NOPTR: Incomplete
LVINF_NOMAP: Incomplete
LVINF_UNUSED: Incomplete

class lvar_uservec_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    lvvec: Incomplete
    lmaps: Incomplete
    stkoff_delta: Incomplete
    ulv_flags: Incomplete
    def swap(self, *args) -> None: ...
    def clear(self, *args) -> None: ...
    def empty(self, *args) -> bool: ...
    def find_info(self, *args) -> 'lvar_saved_info_t *': ...
    def keep_info(self, *args) -> None: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

ULV_PRECISE_DEFEA: Incomplete

def restore_user_lvar_settings(*args) -> bool: ...
def save_user_lvar_settings(*args) -> None: ...

class user_lvar_modifier_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def modify_lvars(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def __disown__(self): ...

def modify_user_lvars(*args) -> bool: ...
def modify_user_lvar_info(*args) -> bool: ...

MLI_NAME: Incomplete
MLI_TYPE: Incomplete
MLI_CMT: Incomplete
MLI_SET_FLAGS: Incomplete
MLI_CLR_FLAGS: Incomplete

def locate_lvar(*args) -> bool: ...
def rename_lvar(*args) -> bool: ...

class udcall_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    name: Incomplete
    tif: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def empty(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

def restore_user_defined_calls(*args) -> bool: ...
def save_user_defined_calls(*args) -> None: ...
def parse_user_call(*args) -> bool: ...
def convert_to_user_call(*args) -> merror_t: ...

class microcode_filter_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def match(self, *args) -> bool: ...
    def apply(self, *args) -> merror_t: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def __disown__(self): ...

def install_microcode_filter(*args) -> bool: ...

class udc_filter_t(microcode_filter_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def cleanup(self, *args) -> None: ...
    def match(self, *args) -> bool: ...
    def apply(self, *args) -> merror_t: ...
    def empty(self, *args) -> bool: ...
    def install(self, *args) -> None: ...
    def remove(self, *args) -> bool: ...
    __swig_destroy__: Incomplete
    def init(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    def __disown__(self): ...

class bitset_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def swap(self, *args) -> None: ...
    def copy(self, *args) -> 'bitset_t &': ...
    def add(self, *args) -> bool: ...
    def sub(self, *args) -> bool: ...
    def cut_at(self, *args) -> bool: ...
    def shift_down(self, *args) -> None: ...
    def has(self, *args) -> bool: ...
    def has_all(self, *args) -> bool: ...
    def has_any(self, *args) -> bool: ...
    def dstr(self, *args) -> 'char const *': ...
    def empty(self, *args) -> bool: ...
    def count(self, *args) -> int: ...
    def last(self, *args) -> int: ...
    def clear(self, *args) -> None: ...
    def fill_with_ones(self, *args) -> None: ...
    def has_common(self, *args) -> bool: ...
    def intersect(self, *args) -> bool: ...
    def is_subset_of(self, *args) -> bool: ...
    def includes(self, *args) -> bool: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def itat(self, *args) -> 'bitset_t::iterator': ...
    def begin(self, *args) -> 'bitset_t::iterator': ...
    def end(self, *args) -> 'bitset_t::iterator': ...
    def front(self, *args) -> int: ...
    def back(self, *args) -> int: ...
    def inc(self, *args) -> None: ...
    def itv(self, *args) -> int: ...
    __len__ = count
    def __iter__(self): ...

bitset_width: Incomplete
bitset_align: Incomplete
bitset_shift: Incomplete

class iterator:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __ref__(self, *args) -> int: ...
    __swig_destroy__: Incomplete

class ivl_t(uval_ivl_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    def empty(self, *args) -> bool: ...
    def clear(self, *args) -> None: ...
    def dstr(self, *args) -> 'char const *': ...
    def extend_to_cover(self, *args) -> bool: ...
    def intersect(self, *args) -> None: ...
    def overlap(self, *args) -> bool: ...
    def includes(self, *args) -> bool: ...
    def contains(self, *args) -> bool: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    __swig_destroy__: Incomplete

class ivl_with_name_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    ivl: Incomplete
    whole: Incomplete
    part: Incomplete
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class ivlset_t(uval_ivl_ivlset_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    def add(self, *args) -> bool: ...
    def addmasked(self, *args) -> bool: ...
    def sub(self, *args) -> bool: ...
    def _print(self, *args) -> None: ...
    def dstr(self, *args) -> 'char const *': ...
    def count(self, *args) -> asize_t: ...
    def has_common(self, *args) -> bool: ...
    def contains(self, *args) -> bool: ...
    def includes(self, *args) -> bool: ...
    def intersect(self, *args) -> bool: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    __swig_destroy__: Incomplete

class rlist_t(bitset_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def dstr(self, *args) -> 'char const *': ...

class mlist_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    reg: Incomplete
    mem: Incomplete
    def __init__(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def addmem(self, *args) -> bool: ...
    def add(self, *args) -> bool: ...
    def sub(self, *args) -> bool: ...
    def count(self, *args) -> asize_t: ...
    def _print(self, *args) -> None: ...
    def dstr(self, *args) -> 'char const *': ...
    def empty(self, *args) -> bool: ...
    def clear(self, *args) -> None: ...
    def has(self, *args) -> bool: ...
    def has_all(self, *args) -> bool: ...
    def has_any(self, *args) -> bool: ...
    def has_memory(self, *args) -> bool: ...
    def has_common(self, *args) -> bool: ...
    def includes(self, *args) -> bool: ...
    def intersect(self, *args) -> bool: ...
    def is_subset_of(self, *args) -> bool: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    __swig_destroy__: Incomplete

def get_temp_regs(*args) -> 'mlist_t const &': ...
def is_kreg(*args) -> bool: ...
def reg2mreg(*args) -> mreg_t: ...
def mreg2reg(*args) -> int: ...
def get_mreg_name(*args) -> 'qstring *': ...

class optinsn_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def func(self, *args) -> int: ...
    def install(self, *args) -> None: ...
    def remove(self, *args) -> bool: ...
    __swig_destroy__: Incomplete
    def __init__(self, *args) -> None: ...
    def __disown__(self): ...

class optblock_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def func(self, *args) -> int: ...
    def install(self, *args) -> None: ...
    def remove(self, *args) -> bool: ...
    __swig_destroy__: Incomplete
    def __init__(self, *args) -> None: ...
    def __disown__(self): ...

class simple_graph_t(ida_gdl.gdl_graph_t):
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __repr__ = _swig_repr
    title: Incomplete
    colored_gdl_edges: Incomplete

class op_parent_info_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    mba: Incomplete
    blk: Incomplete
    topins: Incomplete
    curins: Incomplete
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class minsn_visitor_t(op_parent_info_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    def visit_minsn(self, *args) -> int: ...
    __swig_destroy__: Incomplete
    def __disown__(self): ...

class mop_visitor_t(op_parent_info_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    prune: Incomplete
    def visit_mop(self, *args) -> int: ...
    __swig_destroy__: Incomplete
    def __disown__(self): ...

class scif_visitor_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def visit_scif_mop(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def __disown__(self): ...

class mlist_mop_visitor_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    topins: Incomplete
    curins: Incomplete
    changed: Incomplete
    list: Incomplete
    def visit_mop(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def __disown__(self): ...

class lvar_ref_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    mba: Incomplete
    off: Incomplete
    idx: Incomplete
    def __init__(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def swap(self, *args) -> None: ...
    def var(self, *args) -> 'lvar_t &': ...
    __swig_destroy__: Incomplete

mop_z: Incomplete
mop_r: Incomplete
mop_n: Incomplete
mop_str: Incomplete
mop_d: Incomplete
mop_S: Incomplete
mop_v: Incomplete
mop_b: Incomplete
mop_f: Incomplete
mop_l: Incomplete
mop_a: Incomplete
mop_h: Incomplete
mop_c: Incomplete
mop_fn: Incomplete
mop_p: Incomplete
mop_sc: Incomplete
NOSIZE: Incomplete

class stkvar_ref_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    mba: Incomplete
    off: Incomplete
    def __init__(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def swap(self, *args) -> None: ...
    def get_stkvar(self, *args) -> 'member_t *': ...
    __swig_destroy__: Incomplete

class scif_t(vdloc_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    mba: Incomplete
    name: Incomplete
    type: Incomplete
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class mnumber_t(operand_locator_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    value: Incomplete
    org_value: Incomplete
    def __init__(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def update_value(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class fnumber_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    fnum: Incomplete
    nbytes: Incomplete
    def dereference_uint16(self, *args) -> 'uint16 *': ...
    def dereference_const_uint16(self, *args) -> 'uint16 const *': ...
    def _print(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

SHINS_NUMADDR: Incomplete
SHINS_VALNUM: Incomplete
SHINS_SHORT: Incomplete
SHINS_LDXEA: Incomplete
NO_SIDEFF: Incomplete
WITH_SIDEFF: Incomplete
ONLY_SIDEFF: Incomplete
ANY_REGSIZE: Incomplete
ANY_FPSIZE: Incomplete

class mop_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    t: Incomplete
    oprops: Incomplete
    valnum: Incomplete
    size: Incomplete
    def set_impptr_done(self, *args) -> None: ...
    def set_udt(self, *args) -> None: ...
    def set_undef_val(self, *args) -> None: ...
    def set_lowaddr(self, *args) -> None: ...
    def is_impptr_done(self, *args) -> bool: ...
    def is_udt(self, *args) -> bool: ...
    def probably_floating(self, *args) -> bool: ...
    def is_undef_val(self, *args) -> bool: ...
    def is_lowaddr(self, *args) -> bool: ...
    def is_ccflags(self, *args) -> bool: ...
    def is_pcval(self, *args) -> bool: ...
    def is_glbaddr_from_fixup(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    def assign(self, *args) -> 'mop_t &': ...
    __swig_destroy__: Incomplete
    def zero(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def erase(self, *args) -> None: ...
    def erase_but_keep_size(self, *args) -> None: ...
    def _print(self, *args) -> None: ...
    def dstr(self, *args) -> 'char const *': ...
    def create_from_mlist(self, *args) -> bool: ...
    def create_from_ivlset(self, *args) -> bool: ...
    def create_from_vdloc(self, *args) -> None: ...
    def create_from_scattered_vdloc(self, *args) -> None: ...
    def create_from_insn(self, *args) -> None: ...
    def make_number(self, *args) -> None: ...
    def make_fpnum(self, *args) -> bool: ...
    def _make_reg(self, *args) -> None: ...
    def make_reg(self, *args) -> None: ...
    def _make_lvar(self, *args) -> None: ...
    def _make_gvar(self, *args) -> None: ...
    def make_gvar(self, *args) -> None: ...
    def _make_stkvar(self, *args) -> None: ...
    def make_stkvar(self, *args) -> None: ...
    def make_reg_pair(self, *args) -> None: ...
    def _make_insn(self, *args) -> None: ...
    def make_insn(self, *args) -> None: ...
    def _make_blkref(self, *args) -> None: ...
    def make_blkref(self, *args) -> None: ...
    def make_helper(self, *args) -> None: ...
    def _make_strlit(self, *args) -> None: ...
    def _make_callinfo(self, *args) -> None: ...
    def _make_cases(self, *args) -> None: ...
    def _make_pair(self, *args) -> None: ...
    def empty(self, *args) -> bool: ...
    def is_reg(self, *args) -> bool: ...
    def is_arglist(self, *args) -> bool: ...
    def is_cc(self, *args) -> bool: ...
    def is_bit_reg(self, *args) -> bool: ...
    def is_kreg(self, *args) -> bool: ...
    def is_mob(self, *args) -> bool: ...
    def is_scattered(self, *args) -> bool: ...
    def is_glbaddr(self, *args) -> bool: ...
    def is_stkaddr(self, *args) -> bool: ...
    def is_insn(self, *args) -> bool: ...
    def has_side_effects(self, *args) -> bool: ...
    def may_use_aliased_memory(self, *args) -> bool: ...
    def is01(self, *args) -> bool: ...
    def is_sign_extended_from(self, *args) -> bool: ...
    def is_zero_extended_from(self, *args) -> bool: ...
    def is_extended_from(self, *args) -> bool: ...
    def equal_mops(self, *args) -> bool: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def lexcompare(self, *args) -> int: ...
    def for_all_ops(self, *args) -> int: ...
    def for_all_scattered_submops(self, *args) -> int: ...
    def value(self, *args) -> uint64: ...
    def signed_value(self, *args) -> int64: ...
    def unsigned_value(self, *args) -> uint64: ...
    def update_numop_value(self, *args) -> None: ...
    def is_constant(self, *args) -> bool: ...
    def is_equal_to(self, *args) -> bool: ...
    def is_zero(self, *args) -> bool: ...
    def is_one(self, *args) -> bool: ...
    def is_positive_constant(self, *args) -> bool: ...
    def is_negative_constant(self, *args) -> bool: ...
    def get_stkvar(self, *args) -> 'member_t *': ...
    def get_stkoff(self, *args) -> bool: ...
    def get_insn(self, *args) -> 'minsn_t *': ...
    def make_low_half(self, *args) -> bool: ...
    def make_high_half(self, *args) -> bool: ...
    def make_first_half(self, *args) -> bool: ...
    def make_second_half(self, *args) -> bool: ...
    def shift_mop(self, *args) -> bool: ...
    def change_size(self, *args) -> bool: ...
    def double_size(self, *args) -> bool: ...
    def preserve_side_effects(self, *args) -> bool: ...
    def apply_ld_mcode(self, *args) -> None: ...
    def apply_xdu(self, *args) -> None: ...
    def apply_xds(self, *args) -> None: ...
    def _register(self, *args) -> None: ...
    def _deregister(self, *args) -> None: ...
    def _get_t(self, *args) -> mopt_t: ...
    def _set_t(self, *args) -> None: ...
    def _ensure_no_t(self): ...
    def __dbg_get_meminfo(self, *args) -> qstring: ...
    def __dbg_get_registered_kind(self, *args) -> int: ...
    def _obj_id(self, *args) -> 'PyObject *': ...
    obj_id: Incomplete
    def _ensure_cond(self, ok, cond_str): ...
    def _ensure_no_obj(self, o, attr, attr_is_acquired): ...
    def _ensure_ownership_transferrable(self, v) -> None: ...
    def _acquire_ownership(self, v, acquire): ...
    def _maybe_disown_and_deregister(self) -> None: ...
    def _own_and_register(self) -> None: ...
    def replace_by(self, o) -> None: ...
    def _meminfo(self): ...
    meminfo: Incomplete
    def _get_nnn(self, *args) -> 'mnumber_t *': ...
    def _set_nnn(self, *args) -> None: ...
    nnn: Incomplete
    def _get_d(self, *args) -> 'minsn_t *': ...
    def _set_d(self, *args) -> None: ...
    d: Incomplete
    def _get_s(self, *args) -> 'stkvar_ref_t *': ...
    def _set_s(self, *args) -> None: ...
    s: Incomplete
    def _get_f(self, *args) -> 'mcallinfo_t *': ...
    def _set_f(self, *args) -> None: ...
    f: Incomplete
    def _get_l(self, *args) -> 'lvar_ref_t *': ...
    def _set_l(self, *args) -> None: ...
    l: Incomplete
    def _get_a(self, *args) -> 'mop_addr_t *': ...
    def _set_a(self, *args) -> None: ...
    a: Incomplete
    def _get_c(self, *args) -> 'mcases_t *': ...
    def _set_c(self, *args) -> None: ...
    c: Incomplete
    def _get_fpc(self, *args) -> 'fnumber_t *': ...
    def _set_fpc(self, *args) -> None: ...
    fpc: Incomplete
    def _get_pair(self, *args) -> 'mop_pair_t *': ...
    def _set_pair(self, *args) -> None: ...
    pair: Incomplete
    def _get_scif(self, *args) -> 'scif_t *': ...
    def _set_scif(self, *args) -> None: ...
    scif: Incomplete
    def _get_r(self, *args) -> mreg_t: ...
    def _set_r(self, *args) -> None: ...
    r: Incomplete
    def _get_g(self, *args) -> ea_t: ...
    def _set_g(self, *args) -> None: ...
    g: Incomplete
    def _get_b(self, *args) -> int: ...
    def _set_b(self, *args) -> None: ...
    b: Incomplete
    def _get_cstr(self, *args) -> 'char const *': ...
    def _set_cstr(self, *args) -> None: ...
    cstr: Incomplete
    def _get_helper(self, *args) -> 'char const *': ...
    def _set_helper(self, *args) -> None: ...
    helper: Incomplete

OPROP_IMPDONE: Incomplete
OPROP_UDT: Incomplete
OPROP_FLOAT: Incomplete
OPROP_CCFLAGS: Incomplete
OPROP_UDEFVAL: Incomplete
OPROP_LOWADDR: Incomplete

def lexcompare(*args) -> int: ...

class mop_pair_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    lop: Incomplete
    hop: Incomplete
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class mop_addr_t(mop_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    insize: Incomplete
    outsize: Incomplete
    def __init__(self, *args) -> None: ...
    def lexcompare(self, *args) -> int: ...
    __swig_destroy__: Incomplete

class mcallarg_t(mop_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    ea: Incomplete
    type: Incomplete
    name: Incomplete
    argloc: Incomplete
    flags: Incomplete
    def __init__(self, *args) -> None: ...
    def copy_mop(self, *args) -> None: ...
    def _print(self, *args) -> None: ...
    def dstr(self, *args) -> 'char const *': ...
    def set_regarg(self, *args) -> None: ...
    def make_int(self, *args) -> None: ...
    def make_uint(self, *args) -> None: ...
    __swig_destroy__: Incomplete

ROLE_UNK: Incomplete
ROLE_EMPTY: Incomplete
ROLE_MEMSET: Incomplete
ROLE_MEMSET32: Incomplete
ROLE_MEMSET64: Incomplete
ROLE_MEMCPY: Incomplete
ROLE_STRCPY: Incomplete
ROLE_STRLEN: Incomplete
ROLE_STRCAT: Incomplete
ROLE_TAIL: Incomplete
ROLE_BUG: Incomplete
ROLE_ALLOCA: Incomplete
ROLE_BSWAP: Incomplete
ROLE_PRESENT: Incomplete
ROLE_CONTAINING_RECORD: Incomplete
ROLE_FASTFAIL: Incomplete
ROLE_READFLAGS: Incomplete
ROLE_IS_MUL_OK: Incomplete
ROLE_SATURATED_MUL: Incomplete
ROLE_BITTEST: Incomplete
ROLE_BITTESTANDSET: Incomplete
ROLE_BITTESTANDRESET: Incomplete
ROLE_BITTESTANDCOMPLEMENT: Incomplete
ROLE_VA_ARG: Incomplete
ROLE_VA_COPY: Incomplete
ROLE_VA_START: Incomplete
ROLE_VA_END: Incomplete
ROLE_ROL: Incomplete
ROLE_ROR: Incomplete
ROLE_CFSUB3: Incomplete
ROLE_OFSUB3: Incomplete
ROLE_ABS: Incomplete
ROLE_3WAYCMP0: Incomplete
ROLE_3WAYCMP1: Incomplete
ROLE_WMEMCPY: Incomplete
ROLE_WMEMSET: Incomplete
ROLE_WCSCPY: Incomplete
ROLE_WCSLEN: Incomplete
ROLE_WCSCAT: Incomplete
ROLE_SSE_CMP4: Incomplete
ROLE_SSE_CMP8: Incomplete
FUNC_NAME_MEMCPY: Incomplete
FUNC_NAME_WMEMCPY: Incomplete
FUNC_NAME_MEMSET: Incomplete
FUNC_NAME_WMEMSET: Incomplete
FUNC_NAME_MEMSET32: Incomplete
FUNC_NAME_MEMSET64: Incomplete
FUNC_NAME_STRCPY: Incomplete
FUNC_NAME_WCSCPY: Incomplete
FUNC_NAME_STRLEN: Incomplete
FUNC_NAME_WCSLEN: Incomplete
FUNC_NAME_STRCAT: Incomplete
FUNC_NAME_WCSCAT: Incomplete
FUNC_NAME_TAIL: Incomplete
FUNC_NAME_VA_ARG: Incomplete
FUNC_NAME_EMPTY: Incomplete
FUNC_NAME_PRESENT: Incomplete
FUNC_NAME_CONTAINING_RECORD: Incomplete
FUNC_NAME_MORESTACK: Incomplete

class mcallinfo_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    callee: Incomplete
    solid_args: Incomplete
    call_spd: Incomplete
    stkargs_top: Incomplete
    cc: Incomplete
    args: Incomplete
    retregs: Incomplete
    return_type: Incomplete
    return_argloc: Incomplete
    return_regs: Incomplete
    spoiled: Incomplete
    pass_regs: Incomplete
    visible_memory: Incomplete
    dead_regs: Incomplete
    flags: Incomplete
    role: Incomplete
    fti_attrs: Incomplete
    def __init__(self, *args) -> None: ...
    def lexcompare(self, *args) -> int: ...
    def set_type(self, *args) -> bool: ...
    def get_type(self, *args) -> tinfo_t: ...
    def is_vararg(self, *args) -> bool: ...
    def _print(self, *args) -> None: ...
    def dstr(self, *args) -> 'char const *': ...
    __swig_destroy__: Incomplete

FCI_PROP: Incomplete
FCI_DEAD: Incomplete
FCI_FINAL: Incomplete
FCI_NORET: Incomplete
FCI_PURE: Incomplete
FCI_NOSIDE: Incomplete
FCI_SPLOK: Incomplete
FCI_HASCALL: Incomplete
FCI_HASFMT: Incomplete
FCI_EXPLOCS: Incomplete

class mcases_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    values: Incomplete
    targets: Incomplete
    def swap(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def empty(self, *args) -> bool: ...
    def size(self, *args) -> size_t: ...
    def resize(self, *args) -> None: ...
    def _print(self, *args) -> None: ...
    def dstr(self, *args) -> 'char const *': ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class voff_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    off: Incomplete
    type: Incomplete
    def __init__(self, *args) -> None: ...
    def set(self, *args) -> None: ...
    def set_stkoff(self, *args) -> None: ...
    def set_reg(self, *args) -> None: ...
    def undef(self, *args) -> None: ...
    def defined(self, *args) -> bool: ...
    def is_reg(self, *args) -> bool: ...
    def is_stkoff(self, *args) -> bool: ...
    def get_reg(self, *args) -> mreg_t: ...
    def get_stkoff(self, *args) -> sval_t: ...
    def inc(self, *args) -> None: ...
    def add(self, *args) -> voff_t: ...
    def diff(self, *args) -> sval_t: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    __swig_destroy__: Incomplete

class vivl_t(voff_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    size: Incomplete
    def __init__(self, *args) -> None: ...
    def set(self, *args) -> None: ...
    def set_stkoff(self, *args) -> None: ...
    def set_reg(self, *args) -> None: ...
    def extend_to_cover(self, *args) -> bool: ...
    def intersect(self, *args) -> uval_t: ...
    def overlap(self, *args) -> bool: ...
    def includes(self, *args) -> bool: ...
    def contains(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def __eq__(self, *args) -> bool: ...
    def _print(self, *args) -> None: ...
    def dstr(self, *args) -> 'char const *': ...
    __swig_destroy__: Incomplete

class chain_t(ida_pro.intvec_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    width: Incomplete
    varnum: Incomplete
    flags: Incomplete
    def __init__(self, *args) -> None: ...
    def set_value(self, *args) -> None: ...
    def key(self, *args) -> 'voff_t const &': ...
    def is_inited(self, *args) -> bool: ...
    def is_reg(self, *args) -> bool: ...
    def is_stkoff(self, *args) -> bool: ...
    def is_replaced(self, *args) -> bool: ...
    def is_overlapped(self, *args) -> bool: ...
    def is_fake(self, *args) -> bool: ...
    def is_passreg(self, *args) -> bool: ...
    def is_term(self, *args) -> bool: ...
    def set_inited(self, *args) -> None: ...
    def set_replaced(self, *args) -> None: ...
    def set_overlapped(self, *args) -> None: ...
    def set_term(self, *args) -> None: ...
    def get_reg(self, *args) -> mreg_t: ...
    def get_stkoff(self, *args) -> sval_t: ...
    def overlap(self, *args) -> bool: ...
    def includes(self, *args) -> bool: ...
    def endoff(self, *args) -> 'voff_t const': ...
    def __lt__(self, *args) -> bool: ...
    def _print(self, *args) -> None: ...
    def dstr(self, *args) -> 'char const *': ...
    def append_list(self, *args) -> None: ...
    def clear_varnum(self, *args) -> None: ...
    __swig_destroy__: Incomplete

CHF_INITED: Incomplete
CHF_REPLACED: Incomplete
CHF_OVER: Incomplete
CHF_FAKE: Incomplete
CHF_PASSTHRU: Incomplete
CHF_TERM: Incomplete
SIZEOF_BLOCK_CHAINS: Incomplete

class block_chains_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def get_reg_chain(self, *args) -> 'chain_t *': ...
    def get_stk_chain(self, *args) -> 'chain_t *': ...
    def get_chain(self, *args) -> 'chain_t *': ...
    def _print(self, *args) -> None: ...
    def dstr(self, *args) -> 'char const *': ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class chain_visitor_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    parent: Incomplete
    def visit_chain(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def __disown__(self): ...

class graph_chains_t(block_chains_vec_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    __swig_destroy__: Incomplete
    def for_all_chains(self, *args) -> int: ...
    def is_locked(self, *args) -> bool: ...
    def acquire(self, *args) -> None: ...
    def release(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def __init__(self, *args) -> None: ...

GCA_EMPTY: Incomplete
GCA_SPEC: Incomplete
GCA_ALLOC: Incomplete
GCA_NALLOC: Incomplete
GCA_OFIRST: Incomplete
GCA_OLAST: Incomplete

class minsn_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    opcode: Incomplete
    iprops: Incomplete
    next: Incomplete
    prev: Incomplete
    ea: Incomplete
    l: Incomplete
    r: Incomplete
    d: Incomplete
    def is_optional(self, *args) -> bool: ...
    def is_combined(self, *args) -> bool: ...
    def is_farcall(self, *args) -> bool: ...
    def is_cleaning_pop(self, *args) -> bool: ...
    def is_extstx(self, *args) -> bool: ...
    def is_tailcall(self, *args) -> bool: ...
    def is_fpinsn(self, *args) -> bool: ...
    def is_assert(self, *args) -> bool: ...
    def is_persistent(self, *args) -> bool: ...
    def is_wild_match(self, *args) -> bool: ...
    def is_propagatable(self, *args) -> bool: ...
    def is_ignlowsrc(self, *args) -> bool: ...
    def is_inverted_jx(self, *args) -> bool: ...
    def was_noret_icall(self, *args) -> bool: ...
    def is_multimov(self, *args) -> bool: ...
    def is_combinable(self, *args) -> bool: ...
    def was_split(self, *args) -> bool: ...
    def is_mbarrier(self, *args) -> bool: ...
    def was_unmerged(self, *args) -> bool: ...
    def set_optional(self, *args) -> None: ...
    def clr_combined(self, *args) -> None: ...
    def set_farcall(self, *args) -> None: ...
    def set_cleaning_pop(self, *args) -> None: ...
    def set_extstx(self, *args) -> None: ...
    def set_tailcall(self, *args) -> None: ...
    def clr_tailcall(self, *args) -> None: ...
    def set_fpinsn(self, *args) -> None: ...
    def clr_fpinsn(self, *args) -> None: ...
    def set_assert(self, *args) -> None: ...
    def clr_assert(self, *args) -> None: ...
    def set_persistent(self, *args) -> None: ...
    def set_wild_match(self, *args) -> None: ...
    def clr_propagatable(self, *args) -> None: ...
    def set_ignlowsrc(self, *args) -> None: ...
    def clr_ignlowsrc(self, *args) -> None: ...
    def set_inverted_jx(self, *args) -> None: ...
    def set_noret_icall(self, *args) -> None: ...
    def clr_noret_icall(self, *args) -> None: ...
    def set_multimov(self, *args) -> None: ...
    def clr_multimov(self, *args) -> None: ...
    def set_combinable(self, *args) -> None: ...
    def clr_combinable(self, *args) -> None: ...
    def set_mbarrier(self, *args) -> None: ...
    def set_unmerged(self, *args) -> None: ...
    def set_split_size(self, *args) -> None: ...
    def get_split_size(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def _print(self, *args) -> None: ...
    def dstr(self, *args) -> 'char const *': ...
    def setaddr(self, *args) -> None: ...
    def optimize_solo(self, *args) -> int: ...
    def optimize_subtree(self, *args) -> int: ...
    def for_all_ops(self, *args) -> int: ...
    def for_all_insns(self, *args) -> int: ...
    def _make_nop(self, *args) -> None: ...
    def equal_insns(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def lexcompare(self, *args) -> int: ...
    def is_noret_call(self, *args) -> bool: ...
    def is_unknown_call(self, *args) -> bool: ...
    def is_helper(self, *args) -> bool: ...
    def find_call(self, *args) -> 'minsn_t *': ...
    def contains_call(self, *args) -> bool: ...
    def has_side_effects(self, *args) -> bool: ...
    def get_role(self, *args) -> funcrole_t: ...
    def is_memcpy(self, *args) -> bool: ...
    def is_memset(self, *args) -> bool: ...
    def is_alloca(self, *args) -> bool: ...
    def is_bswap(self, *args) -> bool: ...
    def is_readflags(self, *args) -> bool: ...
    def contains_opcode(self, *args) -> bool: ...
    def find_opcode(self, *args) -> 'minsn_t *': ...
    def find_ins_op(self, *args) -> 'minsn_t *': ...
    def find_num_op(self, *args) -> 'mop_t *': ...
    def is_mov(self, *args) -> bool: ...
    def is_like_move(self, *args) -> bool: ...
    def modifies_d(self, *args) -> bool: ...
    def modifies_pair_mop(self, *args) -> bool: ...
    def is_between(self, *args) -> bool: ...
    def is_after(self, *args) -> bool: ...
    def may_use_aliased_memory(self, *args) -> bool: ...
    def serialize(self, *args) -> int: ...
    def deserialize(self, *args) -> bool: ...
    def _register(self, *args) -> None: ...
    def _deregister(self, *args) -> None: ...
    def __dbg_get_meminfo(self, *args) -> qstring: ...
    def __dbg_get_registered_kind(self, *args) -> int: ...
    def _obj_id(self, *args) -> 'PyObject *': ...
    obj_id: Incomplete
    def _ensure_cond(self, ok, cond_str): ...
    def _ensure_no_obj(self, o, attr, attr_is_acquired): ...
    def _ensure_ownership_transferrable(self, v) -> None: ...
    def _acquire_ownership(self, v, acquire): ...
    def _maybe_disown_and_deregister(self) -> None: ...
    def _own_and_register(self) -> None: ...
    def replace_by(self, o) -> None: ...
    def _meminfo(self): ...
    meminfo: Incomplete
    __swig_destroy__: Incomplete

IPROP_OPTIONAL: Incomplete
IPROP_PERSIST: Incomplete
IPROP_WILDMATCH: Incomplete
IPROP_CLNPOP: Incomplete
IPROP_FPINSN: Incomplete
IPROP_FARCALL: Incomplete
IPROP_TAILCALL: Incomplete
IPROP_ASSERT: Incomplete
IPROP_SPLIT: Incomplete
IPROP_SPLIT1: Incomplete
IPROP_SPLIT2: Incomplete
IPROP_SPLIT4: Incomplete
IPROP_SPLIT8: Incomplete
IPROP_COMBINED: Incomplete
IPROP_EXTSTX: Incomplete
IPROP_IGNLOWSRC: Incomplete
IPROP_INV_JX: Incomplete
IPROP_WAS_NORET: Incomplete
IPROP_MULTI_MOV: Incomplete
IPROP_DONT_PROP: Incomplete
IPROP_DONT_COMB: Incomplete
IPROP_MBARRIER: Incomplete
IPROP_UNMERGED: Incomplete
OPTI_ADDREXPRS: Incomplete
OPTI_MINSTKREF: Incomplete
OPTI_COMBINSNS: Incomplete
OPTI_NO_LDXOPT: Incomplete
EQ_IGNSIZE: Incomplete
EQ_IGNCODE: Incomplete
EQ_CMPDEST: Incomplete
EQ_OPTINSN: Incomplete
NORET_IGNORE_WAS_NORET_ICALL: Incomplete
NORET_FORBID_ANALYSIS: Incomplete

def getf_reginsn(*args) -> 'minsn_t *': ...
def getb_reginsn(*args) -> 'minsn_t *': ...

BLT_NONE: Incomplete
BLT_STOP: Incomplete
BLT_0WAY: Incomplete
BLT_1WAY: Incomplete
BLT_2WAY: Incomplete
BLT_NWAY: Incomplete
BLT_XTRN: Incomplete

class mblock_t:
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __repr__ = _swig_repr
    nextb: Incomplete
    prevb: Incomplete
    flags: Incomplete
    start: Incomplete
    end: Incomplete
    head: Incomplete
    tail: Incomplete
    mba: Incomplete
    serial: Incomplete
    type: Incomplete
    dead_at_start: Incomplete
    mustbuse: Incomplete
    maybuse: Incomplete
    mustbdef: Incomplete
    maybdef: Incomplete
    dnu: Incomplete
    maxbsp: Incomplete
    minbstkref: Incomplete
    minbargref: Incomplete
    predset: Incomplete
    succset: Incomplete
    def mark_lists_dirty(self, *args) -> None: ...
    def request_propagation(self, *args) -> None: ...
    def needs_propagation(self, *args) -> bool: ...
    def request_demote64(self, *args) -> None: ...
    def lists_dirty(self, *args) -> bool: ...
    def lists_ready(self, *args) -> bool: ...
    def make_lists_ready(self, *args) -> int: ...
    def npred(self, *args) -> int: ...
    def nsucc(self, *args) -> int: ...
    def pred(self, *args) -> int: ...
    def succ(self, *args) -> int: ...
    __swig_destroy__: Incomplete
    def empty(self, *args) -> bool: ...
    def _print(self, *args) -> None: ...
    def dump(self, *args) -> None: ...
    def dump_block(self, *args) -> None: ...
    def insert_into_block(self, *args) -> 'minsn_t *': ...
    def remove_from_block(self, *args) -> 'minsn_t *': ...
    def for_all_insns(self, *args) -> int: ...
    def for_all_ops(self, *args) -> int: ...
    def for_all_uses(self, *args) -> int: ...
    def optimize_insn(self, *args) -> int: ...
    def optimize_block(self, *args) -> int: ...
    def build_lists(self, *args) -> int: ...
    def optimize_useless_jump(self, *args) -> int: ...
    def append_use_list(self, *args) -> None: ...
    def append_def_list(self, *args) -> None: ...
    def build_use_list(self, *args) -> mlist_t: ...
    def build_def_list(self, *args) -> mlist_t: ...
    def is_used(self, *args) -> bool: ...
    def find_first_use(self, *args) -> 'minsn_t *': ...
    def is_redefined(self, *args) -> bool: ...
    def find_redefinition(self, *args) -> 'minsn_t *': ...
    def is_rhs_redefined(self, *args) -> bool: ...
    def find_access(self, *args) -> 'minsn_t *': ...
    def find_def(self, *args) -> 'minsn_t *': ...
    def find_use(self, *args) -> 'minsn_t *': ...
    def get_valranges(self, *args) -> bool: ...
    def make_nop(self, *args) -> None: ...
    def get_reginsn_qty(self, *args) -> size_t: ...
    def is_call_block(self, *args) -> bool: ...
    def is_unknown_call(self, *args) -> bool: ...
    def is_nway(self, *args) -> bool: ...
    def is_branch(self, *args) -> bool: ...
    def is_simple_goto_block(self, *args) -> bool: ...
    def is_simple_jcnd_block(self, *args) -> bool: ...
    def preds(self) -> Generator[Incomplete, None, None]: ...
    def succs(self) -> Generator[Incomplete, None, None]: ...

MBL_PRIV: Incomplete
MBL_NONFAKE: Incomplete
MBL_FAKE: Incomplete
MBL_GOTO: Incomplete
MBL_TCAL: Incomplete
MBL_PUSH: Incomplete
MBL_DMT64: Incomplete
MBL_COMB: Incomplete
MBL_PROP: Incomplete
MBL_DEAD: Incomplete
MBL_LIST: Incomplete
MBL_INCONST: Incomplete
MBL_CALL: Incomplete
MBL_BACKPROP: Incomplete
MBL_NORET: Incomplete
MBL_DSLOT: Incomplete
MBL_VALRANGES: Incomplete
MBL_KEEP: Incomplete
FD_BACKWARD: Incomplete
FD_FORWARD: Incomplete
FD_USE: Incomplete
FD_DEF: Incomplete
FD_DIRTY: Incomplete
VR_AT_START: Incomplete
VR_AT_END: Incomplete
VR_EXACT: Incomplete
WARN_VARARG_REGS: Incomplete
WARN_ILL_PURGED: Incomplete
WARN_ILL_FUNCTYPE: Incomplete
WARN_VARARG_TCAL: Incomplete
WARN_VARARG_NOSTK: Incomplete
WARN_VARARG_MANY: Incomplete
WARN_ADDR_OUTARGS: Incomplete
WARN_DEP_UNK_CALLS: Incomplete
WARN_ILL_ELLIPSIS: Incomplete
WARN_GUESSED_TYPE: Incomplete
WARN_EXP_LINVAR: Incomplete
WARN_WIDEN_CHAINS: Incomplete
WARN_BAD_PURGED: Incomplete
WARN_CBUILD_LOOPS: Incomplete
WARN_NO_SAVE_REST: Incomplete
WARN_ODD_INPUT_REG: Incomplete
WARN_ODD_ADDR_USE: Incomplete
WARN_MUST_RET_FP: Incomplete
WARN_ILL_FPU_STACK: Incomplete
WARN_SELFREF_PROP: Incomplete
WARN_WOULD_OVERLAP: Incomplete
WARN_ARRAY_INARG: Incomplete
WARN_MAX_ARGS: Incomplete
WARN_BAD_FIELD_TYPE: Incomplete
WARN_WRITE_CONST: Incomplete
WARN_BAD_RETVAR: Incomplete
WARN_FRAG_LVAR: Incomplete
WARN_HUGE_STKOFF: Incomplete
WARN_UNINITED_REG: Incomplete
WARN_FIXED_MACRO: Incomplete
WARN_WRONG_VA_OFF: Incomplete
WARN_CR_NOFIELD: Incomplete
WARN_CR_BADOFF: Incomplete
WARN_BAD_STROFF: Incomplete
WARN_BAD_VARSIZE: Incomplete
WARN_UNSUPP_REG: Incomplete
WARN_UNALIGNED_ARG: Incomplete
WARN_BAD_STD_TYPE: Incomplete
WARN_BAD_CALL_SP: Incomplete
WARN_MISSED_SWITCH: Incomplete
WARN_BAD_SP: Incomplete
WARN_BAD_STKPNT: Incomplete
WARN_UNDEF_LVAR: Incomplete
WARN_JUMPOUT: Incomplete
WARN_BAD_VALRNG: Incomplete
WARN_BAD_SHADOW: Incomplete
WARN_OPT_VALRNG: Incomplete
WARN_RET_LOCREF: Incomplete
WARN_BAD_MAPDST: Incomplete
WARN_BAD_INSN: Incomplete
WARN_ODD_ABI: Incomplete
WARN_UNBALANCED_STACK: Incomplete
WARN_OPT_VALRNG2: Incomplete
WARN_OPT_VALRNG3: Incomplete
WARN_OPT_USELESS_JCND: Incomplete
WARN_MAX: Incomplete

class hexwarn_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    ea: Incomplete
    id: Incomplete
    text: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

MMAT_ZERO: Incomplete
MMAT_GENERATED: Incomplete
MMAT_PREOPTIMIZED: Incomplete
MMAT_LOCOPT: Incomplete
MMAT_CALLS: Incomplete
MMAT_GLBOPT1: Incomplete
MMAT_GLBOPT2: Incomplete
MMAT_GLBOPT3: Incomplete
MMAT_LVARS: Incomplete
MMIDX_GLBLOW: Incomplete
MMIDX_LVARS: Incomplete
MMIDX_RETADDR: Incomplete
MMIDX_SHADOW: Incomplete
MMIDX_ARGS: Incomplete
MMIDX_GLBHIGH: Incomplete

class mba_ranges_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    pfn: Incomplete
    ranges: Incomplete
    def __init__(self, *args) -> None: ...
    def start(self, *args) -> ea_t: ...
    def empty(self, *args) -> bool: ...
    def clear(self, *args) -> None: ...
    def is_snippet(self, *args) -> bool: ...
    def is_fragmented(self, *args) -> bool: ...
    __swig_destroy__: Incomplete

class mba_range_iterator_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    rii: Incomplete
    fii: Incomplete
    def is_snippet(self, *args) -> bool: ...
    def set(self, *args) -> bool: ...
    def next(self, *args) -> bool: ...
    def chunk(self, *args) -> 'range_t const &': ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class mba_t:
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __repr__ = _swig_repr
    def precise_defeas(self, *args) -> bool: ...
    def optimized(self, *args) -> bool: ...
    def short_display(self, *args) -> bool: ...
    def show_reduction(self, *args) -> bool: ...
    def graph_insns(self, *args) -> bool: ...
    def loaded_gdl(self, *args) -> bool: ...
    def should_beautify(self, *args) -> bool: ...
    def rtype_refined(self, *args) -> bool: ...
    def may_refine_rettype(self, *args) -> bool: ...
    def use_wingraph32(self, *args) -> bool: ...
    def display_numaddrs(self, *args) -> bool: ...
    def display_valnums(self, *args) -> bool: ...
    def is_pattern(self, *args) -> bool: ...
    def is_thunk(self, *args) -> bool: ...
    def saverest_done(self, *args) -> bool: ...
    def callinfo_built(self, *args) -> bool: ...
    def really_alloc(self, *args) -> bool: ...
    def lvars_allocated(self, *args) -> bool: ...
    def chain_varnums_ok(self, *args) -> bool: ...
    def returns_fpval(self, *args) -> bool: ...
    def has_passregs(self, *args) -> bool: ...
    def generated_asserts(self, *args) -> bool: ...
    def propagated_asserts(self, *args) -> bool: ...
    def deleted_pairs(self, *args) -> bool: ...
    def common_stkvars_stkargs(self, *args) -> bool: ...
    def lvar_names_ok(self, *args) -> bool: ...
    def lvars_renamed(self, *args) -> bool: ...
    def has_over_chains(self, *args) -> bool: ...
    def valranges_done(self, *args) -> bool: ...
    def argidx_ok(self, *args) -> bool: ...
    def argidx_sorted(self, *args) -> bool: ...
    def code16_bit_removed(self, *args) -> bool: ...
    def has_stack_retval(self, *args) -> bool: ...
    def has_outlines(self, *args) -> bool: ...
    def is_ctr(self, *args) -> bool: ...
    def is_dtr(self, *args) -> bool: ...
    def is_cdtr(self, *args) -> bool: ...
    def prop_complex(self, *args) -> bool: ...
    def get_mba_flags(self, *args) -> int: ...
    def get_mba_flags2(self, *args) -> int: ...
    def set_mba_flags(self, *args) -> None: ...
    def clr_mba_flags(self, *args) -> None: ...
    def set_mba_flags2(self, *args) -> None: ...
    def clr_mba_flags2(self, *args) -> None: ...
    def clr_cdtr(self, *args) -> None: ...
    def calc_shins_flags(self, *args) -> int: ...
    def stkoff_vd2ida(self, *args) -> sval_t: ...
    def stkoff_ida2vd(self, *args) -> sval_t: ...
    def argbase(self, *args) -> sval_t: ...
    def idaloc2vd(self, *args) -> vdloc_t: ...
    def vd2idaloc(self, *args) -> argloc_t: ...
    def is_stkarg(self, *args) -> bool: ...
    def get_ida_argloc(self, *args) -> argloc_t: ...
    mbr: Incomplete
    entry_ea: Incomplete
    last_prolog_ea: Incomplete
    first_epilog_ea: Incomplete
    qty: Incomplete
    npurged: Incomplete
    cc: Incomplete
    tmpstk_size: Incomplete
    frsize: Incomplete
    frregs: Incomplete
    fpd: Incomplete
    pfn_flags: Incomplete
    retsize: Incomplete
    shadow_args: Incomplete
    fullsize: Incomplete
    stacksize: Incomplete
    inargoff: Incomplete
    minstkref: Incomplete
    minstkref_ea: Incomplete
    minargref: Incomplete
    spd_adjust: Incomplete
    aliased_vars: Incomplete
    aliased_args: Incomplete
    gotoff_stkvars: Incomplete
    restricted_memory: Incomplete
    aliased_memory: Incomplete
    nodel_memory: Incomplete
    consumed_argregs: Incomplete
    maturity: Incomplete
    reqmat: Incomplete
    final_type: Incomplete
    idb_type: Incomplete
    idb_spoiled: Incomplete
    spoiled_list: Incomplete
    fti_flags: Incomplete
    deprecated_idb_node: Incomplete
    label: Incomplete
    vars: Incomplete
    argidx: Incomplete
    retvaridx: Incomplete
    error_ea: Incomplete
    error_strarg: Incomplete
    blocks: Incomplete
    natural: Incomplete
    std_ivls: Incomplete
    notes: Incomplete
    occurred_warns: Incomplete
    def write_to_const_detected(self, *args) -> bool: ...
    def bad_call_sp_detected(self, *args) -> bool: ...
    def regargs_is_not_aligned(self, *args) -> bool: ...
    def has_bad_sp(self, *args) -> bool: ...
    __swig_destroy__: Incomplete
    def term(self, *args) -> None: ...
    def get_curfunc(self, *args) -> 'func_t *': ...
    def use_frame(self, *args) -> bool: ...
    def is_snippet(self, *args) -> bool: ...
    def set_maturity(self, *args) -> bool: ...
    def optimize_local(self, *args) -> int: ...
    def build_graph(self, *args) -> merror_t: ...
    def get_graph(self, *args) -> 'mbl_graph_t *': ...
    def analyze_calls(self, *args) -> int: ...
    def optimize_global(self, *args) -> merror_t: ...
    def alloc_lvars(self, *args) -> None: ...
    def dump(self, *args) -> None: ...
    def dump_mba(self, *args) -> None: ...
    def _print(self, *args) -> None: ...
    def verify(self, *args) -> None: ...
    def mark_chains_dirty(self, *args) -> None: ...
    def get_mblock(self, *args) -> 'mblock_t *': ...
    def insert_block(self, *args) -> 'mblock_t *': ...
    def remove_block(self, *args) -> bool: ...
    def copy_block(self, *args) -> 'mblock_t *': ...
    def remove_empty_and_unreachable_blocks(self, *args) -> bool: ...
    def combine_blocks(self, *args) -> bool: ...
    def for_all_ops(self, *args) -> int: ...
    def for_all_insns(self, *args) -> int: ...
    def for_all_topinsns(self, *args) -> int: ...
    def find_mop(self, *args) -> 'mop_t *': ...
    def create_helper_call(self, *args) -> 'minsn_t *': ...
    def get_func_output_lists(self, *args) -> None: ...
    def arg(self, *args) -> 'lvar_t const &': ...
    def alloc_fict_ea(self, *args) -> ea_t: ...
    def map_fict_ea(self, *args) -> ea_t: ...
    def get_std_region(self, *args) -> 'ivl_t const &': ...
    def get_lvars_region(self, *args) -> 'ivl_t const &': ...
    def get_shadow_region(self, *args) -> 'ivl_t const &': ...
    def get_args_region(self, *args) -> 'ivl_t const &': ...
    def get_stack_region(self, *args) -> ivl_t: ...
    def serialize(self, *args) -> None: ...
    @staticmethod
    def deserialize(*args) -> 'mba_t *': ...
    def save_snapshot(self, *args) -> None: ...
    def alloc_kreg(self, *args) -> mreg_t: ...
    def free_kreg(self, *args) -> None: ...
    def set_lvar_name(self, *args) -> bool: ...
    def set_nice_lvar_name(self, *args) -> bool: ...
    def set_user_lvar_name(self, *args) -> bool: ...
    idb_node: Incomplete
    def _register(self, *args) -> None: ...
    def _deregister(self, *args) -> None: ...

MBA_PRCDEFS: Incomplete
MBA_NOFUNC: Incomplete
MBA_PATTERN: Incomplete
MBA_LOADED: Incomplete
MBA_RETFP: Incomplete
MBA_SPLINFO: Incomplete
MBA_PASSREGS: Incomplete
MBA_THUNK: Incomplete
MBA_CMNSTK: Incomplete
MBA_PREOPT: Incomplete
MBA_CMBBLK: Incomplete
MBA_ASRTOK: Incomplete
MBA_CALLS: Incomplete
MBA_ASRPROP: Incomplete
MBA_SAVRST: Incomplete
MBA_RETREF: Incomplete
MBA_GLBOPT: Incomplete
MBA_LVARS0: Incomplete
MBA_LVARS1: Incomplete
MBA_DELPAIRS: Incomplete
MBA_CHVARS: Incomplete
MBA_SHORT: Incomplete
MBA_COLGDL: Incomplete
MBA_INSGDL: Incomplete
MBA_NICE: Incomplete
MBA_REFINE: Incomplete
MBA_WINGR32: Incomplete
MBA_NUMADDR: Incomplete
MBA_VALNUM: Incomplete
MBA_INITIAL_FLAGS: Incomplete
MBA2_LVARNAMES_OK: Incomplete
MBA2_LVARS_RENAMED: Incomplete
MBA2_OVER_CHAINS: Incomplete
MBA2_VALRNG_DONE: Incomplete
MBA2_IS_CTR: Incomplete
MBA2_IS_DTR: Incomplete
MBA2_ARGIDX_OK: Incomplete
MBA2_NO_DUP_CALLS: Incomplete
MBA2_NO_DUP_LVARS: Incomplete
MBA2_UNDEF_RETVAR: Incomplete
MBA2_ARGIDX_SORTED: Incomplete
MBA2_CODE16_BIT: Incomplete
MBA2_STACK_RETVAL: Incomplete
MBA2_HAS_OUTLINES: Incomplete
MBA2_NO_FRAME: Incomplete
MBA2_PROP_COMPLEX: Incomplete
MBA2_DONT_VERIFY: Incomplete
MBA2_INITIAL_FLAGS: Incomplete
MBA2_ALL_FLAGS: Incomplete
NALT_VD: Incomplete
LOCOPT_ALL: Incomplete
LOCOPT_REFINE: Incomplete
LOCOPT_REFINE2: Incomplete
ACFL_LOCOPT: Incomplete
ACFL_BLKOPT: Incomplete
ACFL_GLBPROP: Incomplete
ACFL_GLBDEL: Incomplete
ACFL_GUESS: Incomplete
CPBLK_FAST: Incomplete
CPBLK_MINREF: Incomplete
CPBLK_OPTJMP: Incomplete

def mba_t_deserialize(*args) -> 'mba_t *': ...

class chain_keeper_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def front(self, *args) -> 'block_chains_t &': ...
    def back(self, *args) -> 'block_chains_t &': ...
    def for_all_chains(self, *args) -> int: ...

GC_REGS_AND_STKVARS: Incomplete
GC_ASR: Incomplete
GC_XDSU: Incomplete
GC_END: Incomplete
GC_DIRTY_ALL: Incomplete

class mbl_graph_t(simple_graph_t):
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __repr__ = _swig_repr
    def is_ud_chain_dirty(self, *args) -> bool: ...
    def is_du_chain_dirty(self, *args) -> bool: ...
    def get_chain_stamp(self, *args) -> int: ...
    def get_ud(self, *args) -> 'graph_chains_t *': ...
    def get_du(self, *args) -> 'graph_chains_t *': ...
    def is_redefined_globally(self, *args) -> bool: ...
    def is_used_globally(self, *args) -> bool: ...
    def get_mblock(self, *args) -> 'mblock_t *': ...

class cdg_insn_iterator_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    mba: Incomplete
    ea: Incomplete
    end: Incomplete
    dslot: Incomplete
    dslot_insn: Incomplete
    severed_branch: Incomplete
    is_likely_dslot: Incomplete
    def __init__(self, *args) -> None: ...
    def ok(self, *args) -> bool: ...
    def has_dslot(self, *args) -> bool: ...
    def dslot_with_xrefs(self, *args) -> bool: ...
    def is_severed_dslot(self, *args) -> bool: ...
    def start(self, *args) -> None: ...
    def next(self, *args) -> merror_t: ...
    __swig_destroy__: Incomplete

class codegen_t:
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __repr__ = _swig_repr
    mba: Incomplete
    mb: Incomplete
    insn: Incomplete
    ignore_micro: Incomplete
    ii: Incomplete
    __swig_destroy__: Incomplete
    def analyze_prolog(self, *args) -> merror_t: ...
    def gen_micro(self, *args) -> merror_t: ...
    def load_operand(self, *args) -> mreg_t: ...
    def microgen_completed(self, *args) -> None: ...
    def prepare_gen_micro(self, *args) -> merror_t: ...
    def load_effective_address(self, *args) -> mreg_t: ...
    def store_operand(self, *args) -> bool: ...
    def emit_micro_mvm(self, *args) -> 'minsn_t *': ...
    def emit(self, *args) -> 'minsn_t *': ...

def change_hexrays_config(*args) -> bool: ...
def get_hexrays_version(*args) -> 'char const *': ...
def checkout_hexrays_license(*args) -> bool: ...

OPF_REUSE: Incomplete
OPF_NEW_WINDOW: Incomplete
OPF_REUSE_ACTIVE: Incomplete
OPF_NO_WAIT: Incomplete
OPF_WINDOW_MGMT_MASK: Incomplete

def open_pseudocode(*args) -> 'vdui_t *': ...
def close_pseudocode(*args) -> bool: ...

VDRUN_NEWFILE: Incomplete
VDRUN_APPEND: Incomplete
VDRUN_ONLYNEW: Incomplete
VDRUN_SILENT: Incomplete
VDRUN_SENDIDB: Incomplete
VDRUN_MAYSTOP: Incomplete
VDRUN_CMDLINE: Incomplete
VDRUN_STATS: Incomplete
VDRUN_LUMINA: Incomplete

def decompile_many(*args) -> bool: ...

class hexrays_failure_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    code: Incomplete
    errea: Incomplete
    str: Incomplete
    def __init__(self, *args) -> None: ...
    def desc(self, *args) -> qstring: ...
    __swig_destroy__: Incomplete

class vd_failure_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    hf: Incomplete
    def __init__(self, *args) -> None: ...
    def desc(self, *args) -> qstring: ...
    __swig_destroy__: Incomplete

class vd_interr_t(vd_failure_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

def send_database(*args) -> None: ...

class gco_info_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    name: Incomplete
    stkoff: Incomplete
    regnum: Incomplete
    size: Incomplete
    flags: Incomplete
    def is_reg(self, *args) -> bool: ...
    def is_use(self, *args) -> bool: ...
    def is_def(self, *args) -> bool: ...
    def append_to_list(self, *args) -> bool: ...
    def cvt_to_ivl(self, *args) -> vivl_t: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

GCO_STK: Incomplete
GCO_REG: Incomplete
GCO_USE: Incomplete
GCO_DEF: Incomplete

def get_current_operand(*args) -> bool: ...
def remitem(*args) -> None: ...

cot_empty: Incomplete
cot_comma: Incomplete
cot_asg: Incomplete
cot_asgbor: Incomplete
cot_asgxor: Incomplete
cot_asgband: Incomplete
cot_asgadd: Incomplete
cot_asgsub: Incomplete
cot_asgmul: Incomplete
cot_asgsshr: Incomplete
cot_asgushr: Incomplete
cot_asgshl: Incomplete
cot_asgsdiv: Incomplete
cot_asgudiv: Incomplete
cot_asgsmod: Incomplete
cot_asgumod: Incomplete
cot_tern: Incomplete
cot_lor: Incomplete
cot_land: Incomplete
cot_bor: Incomplete
cot_xor: Incomplete
cot_band: Incomplete
cot_eq: Incomplete
cot_ne: Incomplete
cot_sge: Incomplete
cot_uge: Incomplete
cot_sle: Incomplete
cot_ule: Incomplete
cot_sgt: Incomplete
cot_ugt: Incomplete
cot_slt: Incomplete
cot_ult: Incomplete
cot_sshr: Incomplete
cot_ushr: Incomplete
cot_shl: Incomplete
cot_add: Incomplete
cot_sub: Incomplete
cot_mul: Incomplete
cot_sdiv: Incomplete
cot_udiv: Incomplete
cot_smod: Incomplete
cot_umod: Incomplete
cot_fadd: Incomplete
cot_fsub: Incomplete
cot_fmul: Incomplete
cot_fdiv: Incomplete
cot_fneg: Incomplete
cot_neg: Incomplete
cot_cast: Incomplete
cot_lnot: Incomplete
cot_bnot: Incomplete
cot_ptr: Incomplete
cot_ref: Incomplete
cot_postinc: Incomplete
cot_postdec: Incomplete
cot_preinc: Incomplete
cot_predec: Incomplete
cot_call: Incomplete
cot_idx: Incomplete
cot_memref: Incomplete
cot_memptr: Incomplete
cot_num: Incomplete
cot_fnum: Incomplete
cot_str: Incomplete
cot_obj: Incomplete
cot_var: Incomplete
cot_insn: Incomplete
cot_sizeof: Incomplete
cot_helper: Incomplete
cot_type: Incomplete
cot_last: Incomplete
cit_empty: Incomplete
cit_block: Incomplete
cit_expr: Incomplete
cit_if: Incomplete
cit_for: Incomplete
cit_while: Incomplete
cit_do: Incomplete
cit_switch: Incomplete
cit_break: Incomplete
cit_continue: Incomplete
cit_return: Incomplete
cit_goto: Incomplete
cit_asm: Incomplete
cit_end: Incomplete

def negated_relation(*args) -> ctype_t: ...
def swapped_relation(*args) -> ctype_t: ...
def get_op_signness(*args) -> type_sign_t: ...
def asgop(*args) -> ctype_t: ...
def asgop_revert(*args) -> ctype_t: ...
def op_uses_x(*args) -> bool: ...
def op_uses_y(*args) -> bool: ...
def op_uses_z(*args) -> bool: ...
def is_binary(*args) -> bool: ...
def is_unary(*args) -> bool: ...
def is_relational(*args) -> bool: ...
def is_assignment(*args) -> bool: ...
def accepts_udts(*args) -> bool: ...
def is_prepost(*args) -> bool: ...
def is_commutative(*args) -> bool: ...
def is_additive(*args) -> bool: ...
def is_multiplicative(*args) -> bool: ...
def is_bitop(*args) -> bool: ...
def is_logical(*args) -> bool: ...
def is_loop(*args) -> bool: ...
def is_break_consumer(*args) -> bool: ...
def is_lvalue(*args) -> bool: ...
def accepts_small_udts(*args) -> bool: ...

class cnumber_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    _value: Incomplete
    nf: Incomplete
    def __init__(self, *args) -> None: ...
    def _print(self, *args) -> None: ...
    def value(self, *args) -> uint64: ...
    def assign(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    __swig_destroy__: Incomplete

class var_ref_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    mba: Incomplete
    idx: Incomplete
    def getv(self, *args) -> 'lvar_t &': ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class ctree_visitor_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    cv_flags: Incomplete
    def maintain_parents(self, *args) -> bool: ...
    def must_prune(self, *args) -> bool: ...
    def must_restart(self, *args) -> bool: ...
    def is_postorder(self, *args) -> bool: ...
    def only_insns(self, *args) -> bool: ...
    def prune_now(self, *args) -> None: ...
    def clr_prune(self, *args) -> None: ...
    def set_restart(self, *args) -> None: ...
    def clr_restart(self, *args) -> None: ...
    parents: Incomplete
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def apply_to(self, *args) -> int: ...
    def apply_to_exprs(self, *args) -> int: ...
    def parent_expr(self, *args) -> 'cexpr_t *': ...
    def parent_insn(self, *args) -> 'cinsn_t *': ...
    def visit_insn(self, *args) -> int: ...
    def visit_expr(self, *args) -> int: ...
    def leave_insn(self, *args) -> int: ...
    def leave_expr(self, *args) -> int: ...
    def __disown__(self): ...

CV_FAST: Incomplete
CV_PRUNE: Incomplete
CV_PARENTS: Incomplete
CV_POST: Incomplete
CV_RESTART: Incomplete
CV_INSNS: Incomplete

class ctree_parentee_t(ctree_visitor_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    def recalc_parent_types(self, *args) -> bool: ...
    def get_block(self, *args) -> 'cblock_t *': ...
    __swig_destroy__: Incomplete
    def __disown__(self): ...

class cfunc_parentee_t(ctree_parentee_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    func: Incomplete
    def __init__(self, *args) -> None: ...
    def calc_rvalue_type(self, *args) -> bool: ...
    __swig_destroy__: Incomplete
    def __disown__(self): ...

CMAT_ZERO: Incomplete
CMAT_BUILT: Incomplete
CMAT_TRANS1: Incomplete
CMAT_NICE: Incomplete
CMAT_TRANS2: Incomplete
CMAT_CPA: Incomplete
CMAT_TRANS3: Incomplete
CMAT_CASTED: Incomplete
CMAT_FINAL: Incomplete
ITP_EMPTY: Incomplete
ITP_ARG1: Incomplete
ITP_ARG64: Incomplete
ITP_BRACE1: Incomplete
ITP_INNER_LAST: Incomplete
ITP_ASM: Incomplete
ITP_ELSE: Incomplete
ITP_DO: Incomplete
ITP_SEMI: Incomplete
ITP_CURLY1: Incomplete
ITP_CURLY2: Incomplete
ITP_BRACE2: Incomplete
ITP_COLON: Incomplete
ITP_BLOCK1: Incomplete
ITP_BLOCK2: Incomplete
ITP_CASE: Incomplete
ITP_SIGN: Incomplete

class treeloc_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    ea: Incomplete
    itp: Incomplete
    def __lt__(self, *args) -> bool: ...
    def __eq__(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

RETRIEVE_ONCE: Incomplete
RETRIEVE_ALWAYS: Incomplete

class citem_cmt_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    used: Incomplete
    def __init__(self, *args) -> None: ...
    def c_str(self, *args) -> 'char const *': ...
    def __str__(self, *args) -> 'char const *': ...
    __swig_destroy__: Incomplete

class citem_locator_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    ea: Incomplete
    op: Incomplete
    def __init__(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    __swig_destroy__: Incomplete

class bit_bound_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    nbits: Incomplete
    sbits: Incomplete
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class citem_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    ea: Incomplete
    label_num: Incomplete
    index: Incomplete
    def __init__(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def is_expr(self, *args) -> bool: ...
    def contains_expr(self, *args) -> bool: ...
    def contains_label(self, *args) -> bool: ...
    def find_parent_of(self, *args) -> 'citem_t *': ...
    def find_closest_addr(self, *args) -> 'citem_t *': ...
    def print1(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    cinsn: Incomplete
    cexpr: Incomplete
    def _get_op(self, *args) -> ctype_t: ...
    def _set_op(self, *args) -> None: ...
    def _ensure_no_op(self): ...
    op: Incomplete
    def __dbg_get_meminfo(self, *args) -> qstring: ...
    def __dbg_get_registered_kind(self, *args) -> int: ...
    def _obj_id(self, *args) -> 'PyObject *': ...
    obj_id: Incomplete
    def _ensure_cond(self, ok, cond_str): ...
    def _ensure_no_obj(self, o, attr, attr_is_acquired): ...
    def _ensure_ownership_transferrable(self, v) -> None: ...
    def _acquire_ownership(self, v, acquire): ...
    def _maybe_disown_and_deregister(self) -> None: ...
    def _own_and_register(self) -> None: ...
    def replace_by(self, o) -> None: ...
    def _meminfo(self): ...
    meminfo: Incomplete

class cexpr_t(citem_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    type: Incomplete
    exflags: Incomplete
    def cpadone(self, *args) -> bool: ...
    def is_odd_lvalue(self, *args) -> bool: ...
    def is_fpop(self, *args) -> bool: ...
    def is_cstr(self, *args) -> bool: ...
    def is_undef_val(self, *args) -> bool: ...
    def is_jumpout(self, *args) -> bool: ...
    def is_vftable(self, *args) -> bool: ...
    def set_cpadone(self, *args) -> None: ...
    def set_vftable(self, *args) -> None: ...
    def __init__(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def assign(self, *args) -> 'cexpr_t &': ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    __swig_destroy__: Incomplete
    def _replace_by(self, *args) -> None: ...
    def cleanup(self, *args) -> None: ...
    def put_number(self, *args) -> None: ...
    def print1(self, *args) -> None: ...
    def calc_type(self, *args) -> None: ...
    def equal_effect(self, *args) -> bool: ...
    def is_child_of(self, *args) -> bool: ...
    def contains_operator(self, *args) -> bool: ...
    def contains_comma(self, *args) -> bool: ...
    def contains_insn(self, *args) -> bool: ...
    def contains_insn_or_label(self, *args) -> bool: ...
    def contains_comma_or_insn_or_label(self, *args) -> bool: ...
    def is_nice_expr(self, *args) -> bool: ...
    def is_nice_cond(self, *args) -> bool: ...
    def is_call_object_of(self, *args) -> bool: ...
    def is_call_arg_of(self, *args) -> bool: ...
    def get_type_sign(self, *args) -> type_sign_t: ...
    def is_type_unsigned(self, *args) -> bool: ...
    def is_type_signed(self, *args) -> bool: ...
    def get_high_nbit_bound(self, *args) -> bit_bound_t: ...
    def get_low_nbit_bound(self, *args) -> int: ...
    def requires_lvalue(self, *args) -> bool: ...
    def has_side_effects(self, *args) -> bool: ...
    def numval(self, *args) -> uint64: ...
    def is_const_value(self, *args) -> bool: ...
    def is_negative_const(self, *args) -> bool: ...
    def is_non_negative_const(self, *args) -> bool: ...
    def is_non_zero_const(self, *args) -> bool: ...
    def is_zero_const(self, *args) -> bool: ...
    def get_const_value(self, *args) -> bool: ...
    def maybe_ptr(self, *args) -> bool: ...
    def get_ptr_or_array(self, *args) -> 'cexpr_t *': ...
    def find_op(self, *args) -> 'cexpr_t *': ...
    def find_num_op(self, *args) -> 'cexpr_t *': ...
    def theother(self, *args) -> 'cexpr_t *': ...
    def get_1num_op(self, *args) -> bool: ...
    def dstr(self, *args) -> 'char const *': ...
    def _register(self, *args) -> None: ...
    def _deregister(self, *args) -> None: ...
    def get_v(self, *args) -> 'var_ref_t *': ...
    def set_v(self, *args) -> None: ...
    v: Incomplete
    def _get_n(self, *args) -> 'cnumber_t *': ...
    def _set_n(self, *args) -> None: ...
    n: Incomplete
    def _get_fpc(self, *args) -> 'fnumber_t *': ...
    def _set_fpc(self, *args) -> None: ...
    fpc: Incomplete
    def _get_x(self, *args) -> 'cexpr_t *': ...
    def _set_x(self, *args) -> None: ...
    x: Incomplete
    def _get_y(self, *args) -> 'cexpr_t *': ...
    def _set_y(self, *args) -> None: ...
    y: Incomplete
    def _get_z(self, *args) -> 'cexpr_t *': ...
    def _set_z(self, *args) -> None: ...
    z: Incomplete
    def _get_a(self, *args) -> 'carglist_t *': ...
    def _set_a(self, *args) -> None: ...
    a: Incomplete
    def _get_insn(self, *args) -> 'cinsn_t *': ...
    def _set_insn(self, *args) -> None: ...
    insn: Incomplete
    def _get_m(self, *args) -> int: ...
    def _set_m(self, *args) -> None: ...
    m: Incomplete
    def _get_ptrsize(self, *args) -> int: ...
    def _set_ptrsize(self, *args) -> None: ...
    ptrsize: Incomplete
    def _get_obj_ea(self, *args) -> ea_t: ...
    def _set_obj_ea(self, *args) -> None: ...
    obj_ea: Incomplete
    def _get_refwidth(self, *args) -> int: ...
    def _set_refwidth(self, *args) -> None: ...
    refwidth: Incomplete
    def _get_helper(self, *args) -> 'char const *': ...
    def _set_helper(self, *args) -> None: ...
    helper: Incomplete
    def _get_string(self, *args) -> 'char const *': ...
    def _set_string(self, *args) -> None: ...
    string: Incomplete

EXFL_CPADONE: Incomplete
EXFL_LVALUE: Incomplete
EXFL_FPOP: Incomplete
EXFL_ALONE: Incomplete
EXFL_CSTR: Incomplete
EXFL_PARTIAL: Incomplete
EXFL_UNDEF: Incomplete
EXFL_JUMPOUT: Incomplete
EXFL_VFTABLE: Incomplete
EXFL_ALL: Incomplete

class ceinsn_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    expr: Incomplete
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

CALC_CURLY_BRACES: Incomplete
NO_CURLY_BRACES: Incomplete
USE_CURLY_BRACES: Incomplete

class cif_t(ceinsn_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    ithen: Incomplete
    ielse: Incomplete
    def __init__(self, *args) -> None: ...
    def assign(self, *args) -> 'cif_t &': ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    __swig_destroy__: Incomplete
    def cleanup(self, *args) -> None: ...

class cloop_t(ceinsn_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    body: Incomplete
    def __init__(self, *args) -> None: ...
    def assign(self, *args) -> 'cloop_t &': ...
    __swig_destroy__: Incomplete
    def cleanup(self, *args) -> None: ...

class cfor_t(cloop_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    init: Incomplete
    step: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class cwhile_t(cloop_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class cdo_t(cloop_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class creturn_t(ceinsn_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class cgoto_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    label_num: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class casm_t(ida_pro.eavec_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def one_insn(self, *args) -> bool: ...
    __swig_destroy__: Incomplete

class cinsn_t(citem_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __init__(self, *args) -> None: ...
    def swap(self, *args) -> None: ...
    def assign(self, *args) -> 'cinsn_t &': ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    __swig_destroy__: Incomplete
    def _replace_by(self, *args) -> None: ...
    def cleanup(self, *args) -> None: ...
    def zero(self, *args) -> None: ...
    def new_insn(self, *args) -> 'cinsn_t &': ...
    def create_if(self, *args) -> 'cif_t &': ...
    def _print(self, *args) -> None: ...
    def print1(self, *args) -> None: ...
    def is_ordinary_flow(self, *args) -> bool: ...
    def contains_insn(self, *args) -> bool: ...
    def collect_free_breaks(self, *args) -> bool: ...
    def collect_free_continues(self, *args) -> bool: ...
    def contains_free_break(self, *args) -> bool: ...
    def contains_free_continue(self, *args) -> bool: ...
    def dstr(self, *args) -> 'char const *': ...
    def _register(self, *args) -> None: ...
    def _deregister(self, *args) -> None: ...
    @staticmethod
    def insn_is_epilog(*args) -> bool: ...
    def is_epilog(self): ...
    def _get_cblock(self, *args) -> 'cblock_t *': ...
    def _set_cblock(self, *args) -> None: ...
    cblock: Incomplete
    def _get_cexpr(self, *args) -> 'cexpr_t *': ...
    def _set_cexpr(self, *args) -> None: ...
    cexpr: Incomplete
    def _get_cif(self, *args) -> 'cif_t *': ...
    def _set_cif(self, *args) -> None: ...
    cif: Incomplete
    def _get_cfor(self, *args) -> 'cfor_t *': ...
    def _set_cfor(self, *args) -> None: ...
    cfor: Incomplete
    def _get_cwhile(self, *args) -> 'cwhile_t *': ...
    def _set_cwhile(self, *args) -> None: ...
    cwhile: Incomplete
    def _get_cdo(self, *args) -> 'cdo_t *': ...
    def _set_cdo(self, *args) -> None: ...
    cdo: Incomplete
    def _get_cswitch(self, *args) -> 'cswitch_t *': ...
    def _set_cswitch(self, *args) -> None: ...
    cswitch: Incomplete
    def _get_creturn(self, *args) -> 'creturn_t *': ...
    def _set_creturn(self, *args) -> None: ...
    creturn: Incomplete
    def _get_cgoto(self, *args) -> 'cgoto_t *': ...
    def _set_cgoto(self, *args) -> None: ...
    cgoto: Incomplete
    def _get_casm(self, *args) -> 'casm_t *': ...
    def _set_casm(self, *args) -> None: ...
    casm: Incomplete

def cinsn_t_insn_is_epilog(*args) -> bool: ...

class cblock_t(cinsn_list_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def _deregister(self, *args) -> None: ...

class carg_t(cexpr_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    is_vararg: Incomplete
    formal_type: Incomplete
    def consume_cexpr(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class carglist_t(qvector_carg_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    functype: Incomplete
    flags: Incomplete
    def __init__(self, *args) -> None: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    __swig_destroy__: Incomplete

CFL_FINAL: Incomplete
CFL_HELPER: Incomplete
CFL_NORET: Incomplete

class ccase_t(cinsn_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    values: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def size(self, *args) -> size_t: ...
    def value(self, *args) -> 'uint64 const &': ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class ccases_t(qvector_ccase_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class cswitch_t(ceinsn_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    mvnf: Incomplete
    cases: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class ctree_anchor_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    value: Incomplete
    def get_index(self, *args) -> int: ...
    def get_itp(self, *args) -> item_preciser_t: ...
    def is_valid_anchor(self, *args) -> bool: ...
    def is_citem_anchor(self, *args) -> bool: ...
    def is_lvar_anchor(self, *args) -> bool: ...
    def is_itp_anchor(self, *args) -> bool: ...
    def is_blkcmt_anchor(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

ANCHOR_INDEX: Incomplete
ANCHOR_MASK: Incomplete
ANCHOR_CITEM: Incomplete
ANCHOR_LVAR: Incomplete
ANCHOR_ITP: Incomplete
ANCHOR_BLKCMT: Incomplete
VDI_NONE: Incomplete
VDI_EXPR: Incomplete
VDI_LVAR: Incomplete
VDI_FUNC: Incomplete
VDI_TAIL: Incomplete

class ctree_item_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    citype: Incomplete
    it: Incomplete
    e: Incomplete
    i: Incomplete
    l: Incomplete
    f: Incomplete
    def get_memptr(self, *args) -> 'member_t *': ...
    def get_udm(self, *args) -> int: ...
    def get_edm(self, *args) -> int: ...
    def get_lvar(self, *args) -> 'lvar_t *': ...
    def get_ea(self, *args) -> ea_t: ...
    def get_label_num(self, *args) -> int: ...
    def is_citem(self, *args) -> bool: ...
    def _print(self, *args) -> None: ...
    def dstr(self, *args) -> 'char const *': ...
    def _get_it(self, *args) -> 'citem_t *': ...
    def _get_e(self, *args) -> 'cexpr_t *': ...
    def _get_i(self, *args) -> 'cinsn_t *': ...
    def _get_l(self, *args) -> 'lvar_t *': ...
    def _get_f(self, *args) -> 'cfunc_t *': ...
    loc: Incomplete
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

GLN_CURRENT: Incomplete
GLN_GOTO_TARGET: Incomplete
GLN_ALL: Incomplete
FORBID_UNUSED_LABELS: Incomplete
ALLOW_UNUSED_LABELS: Incomplete

def _ll_lnot(*args) -> 'cexpr_t *': ...
def _ll_new_block(*args) -> 'cinsn_t *': ...
def _ll_create_helper(*args) -> 'cexpr_t *': ...
def _ll_call_helper(*args) -> 'cexpr_t *': ...
def _ll_make_num(*args) -> 'cexpr_t *': ...
def _ll_make_ref(*args) -> 'cexpr_t *': ...
def _ll_dereference(*args) -> 'cexpr_t *': ...
def save_user_labels(*args) -> None: ...
def save_user_labels2(*args) -> None: ...
def save_user_cmts(*args) -> None: ...
def save_user_numforms(*args) -> None: ...
def save_user_iflags(*args) -> None: ...
def save_user_unions(*args) -> None: ...
def restore_user_labels(*args) -> 'user_labels_t *': ...
def restore_user_labels2(*args) -> 'user_labels_t *': ...
def restore_user_cmts(*args) -> 'user_cmts_t *': ...
def restore_user_numforms(*args) -> 'user_numforms_t *': ...
def restore_user_iflags(*args) -> 'user_iflags_t *': ...
def restore_user_unions(*args) -> 'user_unions_t *': ...

class cfunc_t:
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __repr__ = _swig_repr
    entry_ea: Incomplete
    mba: Incomplete
    body: Incomplete
    argidx: Incomplete
    maturity: Incomplete
    user_labels: Incomplete
    user_cmts: Incomplete
    numforms: Incomplete
    user_iflags: Incomplete
    user_unions: Incomplete
    refcnt: Incomplete
    statebits: Incomplete
    hdrlines: Incomplete
    treeitems: Incomplete
    __swig_destroy__: Incomplete
    def release(self, *args) -> None: ...
    def build_c_tree(self, *args) -> None: ...
    def verify(self, *args) -> None: ...
    def print_dcl(self, *args) -> None: ...
    def print_func(self, *args) -> None: ...
    def get_func_type(self, *args) -> bool: ...
    def get_lvars(self, *args) -> 'lvars_t *': ...
    def get_stkoff_delta(self, *args) -> sval_t: ...
    def find_label(self, *args) -> 'citem_t *': ...
    def remove_unused_labels(self, *args) -> None: ...
    def get_user_cmt(self, *args) -> 'char const *': ...
    def set_user_cmt(self, *args) -> None: ...
    def get_user_iflags(self, *args) -> int32: ...
    def set_user_iflags(self, *args) -> None: ...
    def has_orphan_cmts(self, *args) -> bool: ...
    def del_orphan_cmts(self, *args) -> int: ...
    def get_user_union_selection(self, *args) -> bool: ...
    def set_user_union_selection(self, *args) -> None: ...
    def save_user_labels(self, *args) -> None: ...
    def save_user_cmts(self, *args) -> None: ...
    def save_user_numforms(self, *args) -> None: ...
    def save_user_iflags(self, *args) -> None: ...
    def save_user_unions(self, *args) -> None: ...
    def get_line_item(self, *args) -> bool: ...
    def get_warnings(self, *args) -> 'hexwarns_t &': ...
    def get_eamap(self, *args) -> 'eamap_t &': ...
    def get_boundaries(self, *args) -> 'boundaries_t &': ...
    def get_pseudocode(self, *args) -> 'strvec_t const &': ...
    def refresh_func_ctext(self, *args) -> None: ...
    def gather_derefs(self, *args) -> bool: ...
    def locked(self, *args) -> bool: ...
    def find_item_coords(self, *args) -> 'PyObject *': ...
    def __str__(self, *args) -> qstring: ...

CIT_COLLAPSED: Incomplete
CFS_BOUNDS: Incomplete
CFS_TEXT: Incomplete
CFS_LVARS_HIDDEN: Incomplete
CFS_LOCKED: Incomplete
DECOMP_NO_WAIT: Incomplete
DECOMP_NO_CACHE: Incomplete
DECOMP_NO_FRAME: Incomplete
DECOMP_WARNINGS: Incomplete
DECOMP_ALL_BLKS: Incomplete
DECOMP_NO_HIDE: Incomplete
DECOMP_NO_XREFS: Incomplete
DECOMP_GXREFS_DEFLT: Incomplete
DECOMP_GXREFS_NOUPD: Incomplete
DECOMP_GXREFS_FORCE: Incomplete
DECOMP_VOID_MBA: Incomplete

def close_hexrays_waitbox(*args) -> None: ...
def decompile(*args) -> cfuncptr_t: ...
def decompile_func(*args) -> cfuncptr_t: ...
def gen_microcode(*args) -> 'mba_t *': ...
def create_empty_mba(*args) -> 'mba_t *': ...
def create_cfunc(*args) -> cfuncptr_t: ...
def mark_cfunc_dirty(*args) -> bool: ...
def clear_cached_cfuncs(*args) -> None: ...
def has_cached_cfunc(*args) -> bool: ...
def get_ctype_name(*args) -> 'char const *': ...
def create_field_name(*args) -> qstring: ...

hxe_flowchart: Incomplete
hxe_stkpnts: Incomplete
hxe_prolog: Incomplete
hxe_microcode: Incomplete
hxe_preoptimized: Incomplete
hxe_locopt: Incomplete
hxe_prealloc: Incomplete
hxe_glbopt: Incomplete
hxe_structural: Incomplete
hxe_maturity: Incomplete
hxe_interr: Incomplete
hxe_combine: Incomplete
hxe_print_func: Incomplete
hxe_func_printed: Incomplete
hxe_resolve_stkaddrs: Incomplete
hxe_build_callinfo: Incomplete
hxe_callinfo_built: Incomplete
hxe_calls_done: Incomplete
hxe_open_pseudocode: Incomplete
hxe_switch_pseudocode: Incomplete
hxe_refresh_pseudocode: Incomplete
hxe_close_pseudocode: Incomplete
hxe_keyboard: Incomplete
hxe_right_click: Incomplete
hxe_double_click: Incomplete
hxe_curpos: Incomplete
hxe_create_hint: Incomplete
hxe_text_ready: Incomplete
hxe_populating_popup: Incomplete
lxe_lvar_name_changed: Incomplete
lxe_lvar_type_changed: Incomplete
lxe_lvar_cmt_changed: Incomplete
lxe_lvar_mapping_changed: Incomplete
hxe_cmt_changed: Incomplete
USE_KEYBOARD: Incomplete
USE_MOUSE: Incomplete

class ctext_position_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    lnnum: Incomplete
    x: Incomplete
    y: Incomplete
    def in_ctree(self, *args) -> bool: ...
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __lt__(self, *args) -> bool: ...
    def __gt__(self, *args) -> bool: ...
    def __le__(self, *args) -> bool: ...
    def __ge__(self, *args) -> bool: ...
    def compare(self, *args) -> int: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

HEXRAYS_API_MAGIC: Incomplete

class history_item_t(ctext_position_t):
    thisown: Incomplete
    __repr__ = _swig_repr
    ea: Incomplete
    end: Incomplete
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class vdui_t:
    thisown: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    __repr__ = _swig_repr
    flags: Incomplete
    def visible(self, *args) -> bool: ...
    def valid(self, *args) -> bool: ...
    def locked(self, *args) -> bool: ...
    def set_visible(self, *args) -> None: ...
    def set_valid(self, *args) -> None: ...
    def set_locked(self, *args) -> bool: ...
    view_idx: Incomplete
    ct: Incomplete
    toplevel: Incomplete
    mba: Incomplete
    cfunc: Incomplete
    last_code: Incomplete
    cpos: Incomplete
    head: Incomplete
    item: Incomplete
    tail: Incomplete
    def refresh_view(self, *args) -> None: ...
    def refresh_ctext(self, *args) -> None: ...
    def switch_to(self, *args) -> None: ...
    def in_ctree(self, *args) -> bool: ...
    def get_number(self, *args) -> 'cnumber_t *': ...
    def get_current_label(self, *args) -> int: ...
    def clear(self, *args) -> None: ...
    def refresh_cpos(self, *args) -> bool: ...
    def get_current_item(self, *args) -> bool: ...
    def ui_rename_lvar(self, *args) -> bool: ...
    def rename_lvar(self, *args) -> bool: ...
    def ui_set_call_type(self, *args) -> bool: ...
    def ui_set_lvar_type(self, *args) -> bool: ...
    def set_lvar_type(self, *args) -> bool: ...
    def set_noptr_lvar(self, *args) -> bool: ...
    def ui_edit_lvar_cmt(self, *args) -> bool: ...
    def set_lvar_cmt(self, *args) -> bool: ...
    def ui_map_lvar(self, *args) -> bool: ...
    def ui_unmap_lvar(self, *args) -> bool: ...
    def map_lvar(self, *args) -> bool: ...
    def set_strmem_type(self, *args) -> bool: ...
    def set_udm_type(self, *args) -> bool: ...
    def rename_strmem(self, *args) -> bool: ...
    def rename_udm(self, *args) -> bool: ...
    def set_global_type(self, *args) -> bool: ...
    def rename_global(self, *args) -> bool: ...
    def rename_label(self, *args) -> bool: ...
    def jump_enter(self, *args) -> bool: ...
    def ctree_to_disasm(self, *args) -> bool: ...
    def calc_cmt_type(self, *args) -> cmt_type_t: ...
    def edit_cmt(self, *args) -> bool: ...
    def edit_func_cmt(self, *args) -> bool: ...
    def del_orphan_cmts(self, *args) -> bool: ...
    def set_num_radix(self, *args) -> bool: ...
    def set_num_enum(self, *args) -> bool: ...
    def set_num_stroff(self, *args) -> bool: ...
    def invert_sign(self, *args) -> bool: ...
    def invert_bits(self, *args) -> bool: ...
    def collapse_item(self, *args) -> bool: ...
    def collapse_lvars(self, *args) -> bool: ...
    def split_item(self, *args) -> bool: ...
    __swig_destroy__: Incomplete

CMT_NONE: Incomplete
CMT_TAIL: Incomplete
CMT_BLOCK1: Incomplete
CMT_BLOCK2: Incomplete
CMT_LVAR: Incomplete
CMT_FUNC: Incomplete
CMT_ALL: Incomplete
VDUI_VISIBLE: Incomplete
VDUI_VALID: Incomplete

class ui_stroff_op_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    text: Incomplete
    offset: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

class ui_stroff_applicator_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    def apply(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete
    def __disown__(self): ...

def select_udt_by_offset(*args) -> int: ...

hx_user_numforms_begin: Incomplete
hx_user_numforms_end: Incomplete
hx_user_numforms_next: Incomplete
hx_user_numforms_prev: Incomplete
hx_user_numforms_first: Incomplete
hx_user_numforms_second: Incomplete
hx_user_numforms_find: Incomplete
hx_user_numforms_insert: Incomplete
hx_user_numforms_erase: Incomplete
hx_user_numforms_clear: Incomplete
hx_user_numforms_size: Incomplete
hx_user_numforms_free: Incomplete
hx_user_numforms_new: Incomplete
hx_lvar_mapping_begin: Incomplete
hx_lvar_mapping_end: Incomplete
hx_lvar_mapping_next: Incomplete
hx_lvar_mapping_prev: Incomplete
hx_lvar_mapping_first: Incomplete
hx_lvar_mapping_second: Incomplete
hx_lvar_mapping_find: Incomplete
hx_lvar_mapping_insert: Incomplete
hx_lvar_mapping_erase: Incomplete
hx_lvar_mapping_clear: Incomplete
hx_lvar_mapping_size: Incomplete
hx_lvar_mapping_free: Incomplete
hx_lvar_mapping_new: Incomplete
hx_udcall_map_begin: Incomplete
hx_udcall_map_end: Incomplete
hx_udcall_map_next: Incomplete
hx_udcall_map_prev: Incomplete
hx_udcall_map_first: Incomplete
hx_udcall_map_second: Incomplete
hx_udcall_map_find: Incomplete
hx_udcall_map_insert: Incomplete
hx_udcall_map_erase: Incomplete
hx_udcall_map_clear: Incomplete
hx_udcall_map_size: Incomplete
hx_udcall_map_free: Incomplete
hx_udcall_map_new: Incomplete
hx_user_cmts_begin: Incomplete
hx_user_cmts_end: Incomplete
hx_user_cmts_next: Incomplete
hx_user_cmts_prev: Incomplete
hx_user_cmts_first: Incomplete
hx_user_cmts_second: Incomplete
hx_user_cmts_find: Incomplete
hx_user_cmts_insert: Incomplete
hx_user_cmts_erase: Incomplete
hx_user_cmts_clear: Incomplete
hx_user_cmts_size: Incomplete
hx_user_cmts_free: Incomplete
hx_user_cmts_new: Incomplete
hx_user_iflags_begin: Incomplete
hx_user_iflags_end: Incomplete
hx_user_iflags_next: Incomplete
hx_user_iflags_prev: Incomplete
hx_user_iflags_first: Incomplete
hx_user_iflags_second: Incomplete
hx_user_iflags_find: Incomplete
hx_user_iflags_insert: Incomplete
hx_user_iflags_erase: Incomplete
hx_user_iflags_clear: Incomplete
hx_user_iflags_size: Incomplete
hx_user_iflags_free: Incomplete
hx_user_iflags_new: Incomplete
hx_user_unions_begin: Incomplete
hx_user_unions_end: Incomplete
hx_user_unions_next: Incomplete
hx_user_unions_prev: Incomplete
hx_user_unions_first: Incomplete
hx_user_unions_second: Incomplete
hx_user_unions_find: Incomplete
hx_user_unions_insert: Incomplete
hx_user_unions_erase: Incomplete
hx_user_unions_clear: Incomplete
hx_user_unions_size: Incomplete
hx_user_unions_free: Incomplete
hx_user_unions_new: Incomplete
hx_user_labels_begin: Incomplete
hx_user_labels_end: Incomplete
hx_user_labels_next: Incomplete
hx_user_labels_prev: Incomplete
hx_user_labels_first: Incomplete
hx_user_labels_second: Incomplete
hx_user_labels_find: Incomplete
hx_user_labels_insert: Incomplete
hx_user_labels_erase: Incomplete
hx_user_labels_clear: Incomplete
hx_user_labels_size: Incomplete
hx_user_labels_free: Incomplete
hx_user_labels_new: Incomplete
hx_eamap_begin: Incomplete
hx_eamap_end: Incomplete
hx_eamap_next: Incomplete
hx_eamap_prev: Incomplete
hx_eamap_first: Incomplete
hx_eamap_second: Incomplete
hx_eamap_find: Incomplete
hx_eamap_insert: Incomplete
hx_eamap_erase: Incomplete
hx_eamap_clear: Incomplete
hx_eamap_size: Incomplete
hx_eamap_free: Incomplete
hx_eamap_new: Incomplete
hx_boundaries_begin: Incomplete
hx_boundaries_end: Incomplete
hx_boundaries_next: Incomplete
hx_boundaries_prev: Incomplete
hx_boundaries_first: Incomplete
hx_boundaries_second: Incomplete
hx_boundaries_find: Incomplete
hx_boundaries_insert: Incomplete
hx_boundaries_erase: Incomplete
hx_boundaries_clear: Incomplete
hx_boundaries_size: Incomplete
hx_boundaries_free: Incomplete
hx_boundaries_new: Incomplete
hx_block_chains_begin: Incomplete
hx_block_chains_end: Incomplete
hx_block_chains_next: Incomplete
hx_block_chains_prev: Incomplete
hx_block_chains_get: Incomplete
hx_block_chains_find: Incomplete
hx_block_chains_insert: Incomplete
hx_block_chains_erase: Incomplete
hx_block_chains_clear: Incomplete
hx_block_chains_size: Incomplete
hx_block_chains_free: Incomplete
hx_block_chains_new: Incomplete
hx_valrng_t_clear: Incomplete
hx_valrng_t_copy: Incomplete
hx_valrng_t_assign: Incomplete
hx_valrng_t_compare: Incomplete
hx_valrng_t_set_eq: Incomplete
hx_valrng_t_set_cmp: Incomplete
hx_valrng_t_reduce_size: Incomplete
hx_valrng_t_intersect_with: Incomplete
hx_valrng_t_unite_with: Incomplete
hx_valrng_t_inverse: Incomplete
hx_valrng_t_has: Incomplete
hx_valrng_t_print: Incomplete
hx_valrng_t_dstr: Incomplete
hx_valrng_t_cvt_to_single_value: Incomplete
hx_valrng_t_cvt_to_cmp: Incomplete
hx_get_merror_desc: Incomplete
hx_reg2mreg: Incomplete
hx_mreg2reg: Incomplete
hx_install_optinsn_handler: Incomplete
hx_remove_optinsn_handler: Incomplete
hx_install_optblock_handler: Incomplete
hx_remove_optblock_handler: Incomplete
hx_must_mcode_close_block: Incomplete
hx_is_mcode_propagatable: Incomplete
hx_negate_mcode_relation: Incomplete
hx_swap_mcode_relation: Incomplete
hx_get_signed_mcode: Incomplete
hx_get_unsigned_mcode: Incomplete
hx_mcode_modifies_d: Incomplete
hx_operand_locator_t_compare: Incomplete
hx_vd_printer_t_print: Incomplete
hx_file_printer_t_print: Incomplete
hx_qstring_printer_t_print: Incomplete
hx_dstr: Incomplete
hx_is_type_correct: Incomplete
hx_is_small_udt: Incomplete
hx_is_nonbool_type: Incomplete
hx_is_bool_type: Incomplete
hx_partial_type_num: Incomplete
hx_get_float_type: Incomplete
hx_get_int_type_by_width_and_sign: Incomplete
hx_get_unk_type: Incomplete
hx_dummy_ptrtype: Incomplete
hx_get_member_type: Incomplete
hx_make_pointer: Incomplete
hx_create_typedef: Incomplete
hx_get_type: Incomplete
hx_set_type: Incomplete
hx_vdloc_t_dstr: Incomplete
hx_vdloc_t_compare: Incomplete
hx_vdloc_t_is_aliasable: Incomplete
hx_print_vdloc: Incomplete
hx_arglocs_overlap: Incomplete
hx_lvar_locator_t_compare: Incomplete
hx_lvar_locator_t_dstr: Incomplete
hx_lvar_t_dstr: Incomplete
hx_lvar_t_is_promoted_arg: Incomplete
hx_lvar_t_accepts_type: Incomplete
hx_lvar_t_set_lvar_type: Incomplete
hx_lvar_t_set_width: Incomplete
hx_lvar_t_append_list_: Incomplete
hx_lvars_t_find_stkvar: Incomplete
hx_lvars_t_find: Incomplete
hx_lvars_t_find_lvar: Incomplete
hx_restore_user_lvar_settings: Incomplete
hx_save_user_lvar_settings: Incomplete
hx_modify_user_lvars: Incomplete
hx_restore_user_defined_calls: Incomplete
hx_save_user_defined_calls: Incomplete
hx_parse_user_call: Incomplete
hx_convert_to_user_call: Incomplete
hx_install_microcode_filter: Incomplete
hx_udc_filter_t_init: Incomplete
hx_udc_filter_t_apply: Incomplete
hx_bitset_t_bitset_t: Incomplete
hx_bitset_t_copy: Incomplete
hx_bitset_t_add: Incomplete
hx_bitset_t_add_: Incomplete
hx_bitset_t_add__: Incomplete
hx_bitset_t_sub: Incomplete
hx_bitset_t_sub_: Incomplete
hx_bitset_t_sub__: Incomplete
hx_bitset_t_cut_at: Incomplete
hx_bitset_t_shift_down: Incomplete
hx_bitset_t_has: Incomplete
hx_bitset_t_has_all: Incomplete
hx_bitset_t_has_any: Incomplete
hx_bitset_t_dstr: Incomplete
hx_bitset_t_empty: Incomplete
hx_bitset_t_count: Incomplete
hx_bitset_t_count_: Incomplete
hx_bitset_t_last: Incomplete
hx_bitset_t_fill_with_ones: Incomplete
hx_bitset_t_has_common: Incomplete
hx_bitset_t_intersect: Incomplete
hx_bitset_t_is_subset_of: Incomplete
hx_bitset_t_compare: Incomplete
hx_bitset_t_goup: Incomplete
hx_ivl_t_dstr: Incomplete
hx_ivl_t_compare: Incomplete
hx_ivlset_t_add: Incomplete
hx_ivlset_t_add_: Incomplete
hx_ivlset_t_addmasked: Incomplete
hx_ivlset_t_sub: Incomplete
hx_ivlset_t_sub_: Incomplete
hx_ivlset_t_has_common: Incomplete
hx_ivlset_t_print: Incomplete
hx_ivlset_t_dstr: Incomplete
hx_ivlset_t_count: Incomplete
hx_ivlset_t_has_common_: Incomplete
hx_ivlset_t_contains: Incomplete
hx_ivlset_t_includes: Incomplete
hx_ivlset_t_intersect: Incomplete
hx_ivlset_t_compare: Incomplete
hx_get_mreg_name: Incomplete
hx_rlist_t_print: Incomplete
hx_rlist_t_dstr: Incomplete
hx_mlist_t_addmem: Incomplete
hx_mlist_t_print: Incomplete
hx_mlist_t_dstr: Incomplete
hx_mlist_t_compare: Incomplete
hx_lvar_ref_t_compare: Incomplete
hx_lvar_ref_t_var: Incomplete
hx_stkvar_ref_t_compare: Incomplete
hx_stkvar_ref_t_get_stkvar: Incomplete
hx_fnumber_t_print: Incomplete
hx_fnumber_t_dstr: Incomplete
hx_mop_t_copy: Incomplete
hx_mop_t_assign: Incomplete
hx_mop_t_swap: Incomplete
hx_mop_t_erase: Incomplete
hx_mop_t_print: Incomplete
hx_mop_t_dstr: Incomplete
hx_mop_t_create_from_mlist: Incomplete
hx_mop_t_create_from_ivlset: Incomplete
hx_mop_t_create_from_vdloc: Incomplete
hx_mop_t_create_from_scattered_vdloc: Incomplete
hx_mop_t_create_from_insn: Incomplete
hx_mop_t_make_number: Incomplete
hx_mop_t_make_fpnum: Incomplete
hx_mop_t_make_reg_pair: Incomplete
hx_mop_t_make_helper: Incomplete
hx_mop_t_is_bit_reg: Incomplete
hx_mop_t_may_use_aliased_memory: Incomplete
hx_mop_t_is01: Incomplete
hx_mop_t_is_sign_extended_from: Incomplete
hx_mop_t_is_zero_extended_from: Incomplete
hx_mop_t_equal_mops: Incomplete
hx_mop_t_lexcompare: Incomplete
hx_mop_t_for_all_ops: Incomplete
hx_mop_t_for_all_scattered_submops: Incomplete
hx_mop_t_is_constant: Incomplete
hx_mop_t_get_stkoff: Incomplete
hx_mop_t_make_low_half: Incomplete
hx_mop_t_make_high_half: Incomplete
hx_mop_t_make_first_half: Incomplete
hx_mop_t_make_second_half: Incomplete
hx_mop_t_shift_mop: Incomplete
hx_mop_t_change_size: Incomplete
hx_mop_t_preserve_side_effects: Incomplete
hx_mop_t_apply_ld_mcode: Incomplete
hx_mcallarg_t_print: Incomplete
hx_mcallarg_t_dstr: Incomplete
hx_mcallarg_t_set_regarg: Incomplete
hx_mcallinfo_t_lexcompare: Incomplete
hx_mcallinfo_t_set_type: Incomplete
hx_mcallinfo_t_get_type: Incomplete
hx_mcallinfo_t_print: Incomplete
hx_mcallinfo_t_dstr: Incomplete
hx_mcases_t_compare: Incomplete
hx_mcases_t_print: Incomplete
hx_mcases_t_dstr: Incomplete
hx_vivl_t_extend_to_cover: Incomplete
hx_vivl_t_intersect: Incomplete
hx_vivl_t_print: Incomplete
hx_vivl_t_dstr: Incomplete
hx_chain_t_print: Incomplete
hx_chain_t_dstr: Incomplete
hx_chain_t_append_list_: Incomplete
hx_block_chains_t_get_chain: Incomplete
hx_block_chains_t_print: Incomplete
hx_block_chains_t_dstr: Incomplete
hx_graph_chains_t_for_all_chains: Incomplete
hx_graph_chains_t_release: Incomplete
hx_minsn_t_init: Incomplete
hx_minsn_t_copy: Incomplete
hx_minsn_t_swap: Incomplete
hx_minsn_t_print: Incomplete
hx_minsn_t_dstr: Incomplete
hx_minsn_t_setaddr: Incomplete
hx_minsn_t_optimize_subtree: Incomplete
hx_minsn_t_for_all_ops: Incomplete
hx_minsn_t_for_all_insns: Incomplete
hx_minsn_t__make_nop: Incomplete
hx_minsn_t_equal_insns: Incomplete
hx_minsn_t_lexcompare: Incomplete
hx_minsn_t_is_noret_call: Incomplete
hx_minsn_t_is_helper: Incomplete
hx_minsn_t_find_call: Incomplete
hx_minsn_t_has_side_effects: Incomplete
hx_minsn_t_find_opcode: Incomplete
hx_minsn_t_find_ins_op: Incomplete
hx_minsn_t_find_num_op: Incomplete
hx_minsn_t_modifies_d: Incomplete
hx_minsn_t_is_between: Incomplete
hx_minsn_t_may_use_aliased_memory: Incomplete
hx_getf_reginsn: Incomplete
hx_getb_reginsn: Incomplete
hx_mblock_t_init: Incomplete
hx_mblock_t_print: Incomplete
hx_mblock_t_dump: Incomplete
hx_mblock_t_vdump_block: Incomplete
hx_mblock_t_insert_into_block: Incomplete
hx_mblock_t_remove_from_block: Incomplete
hx_mblock_t_for_all_insns: Incomplete
hx_mblock_t_for_all_ops: Incomplete
hx_mblock_t_for_all_uses: Incomplete
hx_mblock_t_optimize_insn: Incomplete
hx_mblock_t_optimize_block: Incomplete
hx_mblock_t_build_lists: Incomplete
hx_mblock_t_append_use_list: Incomplete
hx_mblock_t_append_def_list: Incomplete
hx_mblock_t_build_use_list: Incomplete
hx_mblock_t_build_def_list: Incomplete
hx_mblock_t_find_first_use: Incomplete
hx_mblock_t_find_redefinition: Incomplete
hx_mblock_t_is_rhs_redefined: Incomplete
hx_mblock_t_find_access: Incomplete
hx_mblock_t_get_valranges: Incomplete
hx_mba_t_idaloc2vd: Incomplete
hx_mba_t_vd2idaloc: Incomplete
hx_mba_t_term: Incomplete
hx_mba_t_optimize_local: Incomplete
hx_mba_t_build_graph: Incomplete
hx_mba_t_get_graph: Incomplete
hx_mba_t_analyze_calls: Incomplete
hx_mba_t_optimize_global: Incomplete
hx_mba_t_alloc_lvars: Incomplete
hx_mba_t_dump: Incomplete
hx_mba_t_vdump_mba: Incomplete
hx_mba_t_print: Incomplete
hx_mba_t_verify: Incomplete
hx_mba_t_mark_chains_dirty: Incomplete
hx_mba_t_insert_block: Incomplete
hx_mba_t_remove_block: Incomplete
hx_mba_t_remove_empty_and_unreachable_blocks: Incomplete
hx_mba_t_combine_blocks: Incomplete
hx_mba_t_for_all_ops: Incomplete
hx_mba_t_for_all_insns: Incomplete
hx_mba_t_for_all_topinsns: Incomplete
hx_mba_t_find_mop: Incomplete
hx_mba_t_arg: Incomplete
hx_mba_t_serialize: Incomplete
hx_mba_t_deserialize: Incomplete
hx_mbl_graph_t_is_accessed_globally: Incomplete
hx_mbl_graph_t_get_ud: Incomplete
hx_mbl_graph_t_get_du: Incomplete
hx_codegen_t_emit: Incomplete
hx_codegen_t_emit_: Incomplete
hx_is_kreg: Incomplete
hx_get_temp_regs: Incomplete
hx_get_hexrays_version: Incomplete
hx_open_pseudocode: Incomplete
hx_close_pseudocode: Incomplete
hx_get_widget_vdui: Incomplete
hx_decompile_many: Incomplete
hx_hexrays_failure_t_desc: Incomplete
hx_send_database: Incomplete
hx_gco_info_t_append_to_list: Incomplete
hx_get_current_operand: Incomplete
hx_remitem: Incomplete
hx_negated_relation: Incomplete
hx_swapped_relation: Incomplete
hx_get_op_signness: Incomplete
hx_asgop: Incomplete
hx_asgop_revert: Incomplete
hx_cnumber_t_print: Incomplete
hx_cnumber_t_value: Incomplete
hx_cnumber_t_assign: Incomplete
hx_cnumber_t_compare: Incomplete
hx_var_ref_t_compare: Incomplete
hx_ctree_visitor_t_apply_to: Incomplete
hx_ctree_visitor_t_apply_to_exprs: Incomplete
hx_ctree_parentee_t_recalc_parent_types: Incomplete
hx_cfunc_parentee_t_calc_rvalue_type: Incomplete
hx_citem_locator_t_compare: Incomplete
hx_citem_t_contains_expr: Incomplete
hx_citem_t_contains_label: Incomplete
hx_citem_t_find_parent_of: Incomplete
hx_citem_t_find_closest_addr: Incomplete
hx_cexpr_t_assign: Incomplete
hx_cexpr_t_compare: Incomplete
hx_cexpr_t_replace_by: Incomplete
hx_cexpr_t_cleanup: Incomplete
hx_cexpr_t_put_number: Incomplete
hx_cexpr_t_print1: Incomplete
hx_cexpr_t_calc_type: Incomplete
hx_cexpr_t_equal_effect: Incomplete
hx_cexpr_t_is_child_of: Incomplete
hx_cexpr_t_contains_operator: Incomplete
hx_cexpr_t_get_high_nbit_bound: Incomplete
hx_cexpr_t_get_low_nbit_bound: Incomplete
hx_cexpr_t_requires_lvalue: Incomplete
hx_cexpr_t_has_side_effects: Incomplete
hx_cif_t_assign: Incomplete
hx_cif_t_compare: Incomplete
hx_cloop_t_assign: Incomplete
hx_cfor_t_compare: Incomplete
hx_cwhile_t_compare: Incomplete
hx_cdo_t_compare: Incomplete
hx_creturn_t_compare: Incomplete
hx_cgoto_t_compare: Incomplete
hx_casm_t_compare: Incomplete
hx_cinsn_t_assign: Incomplete
hx_cinsn_t_compare: Incomplete
hx_cinsn_t_replace_by: Incomplete
hx_cinsn_t_cleanup: Incomplete
hx_cinsn_t_new_insn: Incomplete
hx_cinsn_t_create_if: Incomplete
hx_cinsn_t_print: Incomplete
hx_cinsn_t_print1: Incomplete
hx_cinsn_t_is_ordinary_flow: Incomplete
hx_cinsn_t_contains_insn: Incomplete
hx_cinsn_t_collect_free_breaks: Incomplete
hx_cinsn_t_collect_free_continues: Incomplete
hx_cblock_t_compare: Incomplete
hx_carglist_t_compare: Incomplete
hx_ccase_t_compare: Incomplete
hx_ccases_t_compare: Incomplete
hx_cswitch_t_compare: Incomplete
hx_ctree_item_t_get_memptr: Incomplete
hx_ctree_item_t_get_lvar: Incomplete
hx_ctree_item_t_get_ea: Incomplete
hx_ctree_item_t_get_label_num: Incomplete
hx_lnot: Incomplete
hx_new_block: Incomplete
hx_vcreate_helper: Incomplete
hx_vcall_helper: Incomplete
hx_make_num: Incomplete
hx_make_ref: Incomplete
hx_dereference: Incomplete
hx_save_user_labels: Incomplete
hx_save_user_cmts: Incomplete
hx_save_user_numforms: Incomplete
hx_save_user_iflags: Incomplete
hx_save_user_unions: Incomplete
hx_restore_user_labels: Incomplete
hx_restore_user_cmts: Incomplete
hx_restore_user_numforms: Incomplete
hx_restore_user_iflags: Incomplete
hx_restore_user_unions: Incomplete
hx_cfunc_t_build_c_tree: Incomplete
hx_cfunc_t_verify: Incomplete
hx_cfunc_t_print_dcl: Incomplete
hx_cfunc_t_print_func: Incomplete
hx_cfunc_t_get_func_type: Incomplete
hx_cfunc_t_get_lvars: Incomplete
hx_cfunc_t_get_stkoff_delta: Incomplete
hx_cfunc_t_find_label: Incomplete
hx_cfunc_t_remove_unused_labels: Incomplete
hx_cfunc_t_get_user_cmt: Incomplete
hx_cfunc_t_set_user_cmt: Incomplete
hx_cfunc_t_get_user_iflags: Incomplete
hx_cfunc_t_set_user_iflags: Incomplete
hx_cfunc_t_has_orphan_cmts: Incomplete
hx_cfunc_t_del_orphan_cmts: Incomplete
hx_cfunc_t_get_user_union_selection: Incomplete
hx_cfunc_t_set_user_union_selection: Incomplete
hx_cfunc_t_get_line_item: Incomplete
hx_cfunc_t_get_warnings: Incomplete
hx_cfunc_t_get_eamap: Incomplete
hx_cfunc_t_get_boundaries: Incomplete
hx_cfunc_t_get_pseudocode: Incomplete
hx_cfunc_t_gather_derefs: Incomplete
hx_cfunc_t_find_item_coords: Incomplete
hx_cfunc_t_cleanup: Incomplete
hx_decompile: Incomplete
hx_gen_microcode: Incomplete
hx_mark_cfunc_dirty: Incomplete
hx_clear_cached_cfuncs: Incomplete
hx_has_cached_cfunc: Incomplete
hx_get_ctype_name: Incomplete
hx_create_field_name: Incomplete
hx_install_hexrays_callback: Incomplete
hx_remove_hexrays_callback: Incomplete
hx_vdui_t_set_locked: Incomplete
hx_vdui_t_refresh_view: Incomplete
hx_vdui_t_refresh_ctext: Incomplete
hx_vdui_t_switch_to: Incomplete
hx_vdui_t_get_number: Incomplete
hx_vdui_t_get_current_label: Incomplete
hx_vdui_t_clear: Incomplete
hx_vdui_t_refresh_cpos: Incomplete
hx_vdui_t_get_current_item: Incomplete
hx_vdui_t_ui_rename_lvar: Incomplete
hx_vdui_t_rename_lvar: Incomplete
hx_vdui_t_ui_set_call_type: Incomplete
hx_vdui_t_ui_set_lvar_type: Incomplete
hx_vdui_t_set_lvar_type: Incomplete
hx_vdui_t_ui_edit_lvar_cmt: Incomplete
hx_vdui_t_set_lvar_cmt: Incomplete
hx_vdui_t_ui_map_lvar: Incomplete
hx_vdui_t_ui_unmap_lvar: Incomplete
hx_vdui_t_map_lvar: Incomplete
hx_vdui_t_set_strmem_type: Incomplete
hx_vdui_t_rename_strmem: Incomplete
hx_vdui_t_set_global_type: Incomplete
hx_vdui_t_rename_global: Incomplete
hx_vdui_t_rename_label: Incomplete
hx_vdui_t_jump_enter: Incomplete
hx_vdui_t_ctree_to_disasm: Incomplete
hx_vdui_t_calc_cmt_type: Incomplete
hx_vdui_t_edit_cmt: Incomplete
hx_vdui_t_edit_func_cmt: Incomplete
hx_vdui_t_del_orphan_cmts: Incomplete
hx_vdui_t_set_num_radix: Incomplete
hx_vdui_t_set_num_enum: Incomplete
hx_vdui_t_set_num_stroff: Incomplete
hx_vdui_t_invert_sign: Incomplete
hx_vdui_t_invert_bits: Incomplete
hx_vdui_t_collapse_item: Incomplete
hx_vdui_t_collapse_lvars: Incomplete
hx_vdui_t_split_item: Incomplete
hx_hexrays_alloc: Incomplete
hx_hexrays_free: Incomplete
hx_vdui_t_set_noptr_lvar: Incomplete
hx_select_udt_by_offset: Incomplete
hx_mblock_t_get_valranges_: Incomplete
hx_cfunc_t_refresh_func_ctext: Incomplete
hx_checkout_hexrays_license: Incomplete
hx_mba_t_copy_block: Incomplete
hx_mblock_t_optimize_useless_jump: Incomplete
hx_mblock_t_get_reginsn_qty: Incomplete
hx_modify_user_lvar_info: Incomplete
hx_cdg_insn_iterator_t_next: Incomplete
hx_restore_user_labels2: Incomplete
hx_save_user_labels2: Incomplete
hx_mba_ranges_t_range_contains: Incomplete
hx_close_hexrays_waitbox: Incomplete
hx_mba_t_map_fict_ea: Incomplete
hx_mba_t_alloc_fict_ea: Incomplete
hx_mba_t_alloc_kreg: Incomplete
hx_mba_t_free_kreg: Incomplete
hx_mba_t_idaloc2vd_: Incomplete
hx_mba_t_vd2idaloc_: Incomplete
hx_bitset_t_fill_gaps: Incomplete
hx_cfunc_t_save_user_labels: Incomplete
hx_cfunc_t_save_user_cmts: Incomplete
hx_cfunc_t_save_user_numforms: Incomplete
hx_cfunc_t_save_user_iflags: Incomplete
hx_cfunc_t_save_user_unions: Incomplete
hx_minsn_t_set_combined: Incomplete
hx_mba_t_save_snapshot: Incomplete
hx_create_cfunc: Incomplete
hx_mba_t_set_maturity: Incomplete
hx_rename_lvar: Incomplete
hx_locate_lvar: Incomplete
hx_mba_t_create_helper_call: Incomplete
hx_lvar_t_append_list: Incomplete
hx_chain_t_append_list: Incomplete
hx_udc_filter_t_cleanup: Incomplete
hx_mba_t_get_curfunc: Incomplete
hx_mop_t__make_gvar: Incomplete
hx_mop_t_make_gvar: Incomplete
hx_cexpr_t_maybe_ptr: Incomplete
hx_minsn_t_serialize: Incomplete
hx_minsn_t_deserialize: Incomplete
hx_mba_t_stkoff_vd2ida: Incomplete
hx_mba_t_stkoff_ida2vd: Incomplete
hx_cexpr_t_dstr: Incomplete
hx_cinsn_t_dstr: Incomplete
hx_ctree_item_t_print: Incomplete
hx_ctree_item_t_dstr: Incomplete
hx_mba_t_set_lvar_name: Incomplete
hx_change_hexrays_config: Incomplete
hx_mba_t_get_func_output_lists: Incomplete
hx_vdui_t_rename_udm: Incomplete
hx_vdui_t_set_udm_type: Incomplete
hx_ctree_item_t_get_udm: Incomplete
hx_ctree_item_t_get_edm: Incomplete

class user_numforms_iterator_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    x: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

def user_numforms_first(*args) -> 'operand_locator_t const &': ...
def user_numforms_second(*args) -> 'number_format_t &': ...
def user_numforms_find(*args) -> user_numforms_iterator_t: ...
def user_numforms_insert(*args) -> user_numforms_iterator_t: ...
def user_numforms_begin(*args) -> user_numforms_iterator_t: ...
def user_numforms_end(*args) -> user_numforms_iterator_t: ...
def user_numforms_next(*args) -> user_numforms_iterator_t: ...
def user_numforms_prev(*args) -> user_numforms_iterator_t: ...
def user_numforms_erase(*args) -> None: ...
def user_numforms_clear(*args) -> None: ...
def user_numforms_size(*args) -> size_t: ...
def user_numforms_free(*args) -> None: ...
def user_numforms_new(*args) -> 'user_numforms_t *': ...

class lvar_mapping_iterator_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    x: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

def lvar_mapping_first(*args) -> 'lvar_locator_t const &': ...
def lvar_mapping_second(*args) -> 'lvar_locator_t &': ...
def lvar_mapping_find(*args) -> lvar_mapping_iterator_t: ...
def lvar_mapping_insert(*args) -> lvar_mapping_iterator_t: ...
def lvar_mapping_begin(*args) -> lvar_mapping_iterator_t: ...
def lvar_mapping_end(*args) -> lvar_mapping_iterator_t: ...
def lvar_mapping_next(*args) -> lvar_mapping_iterator_t: ...
def lvar_mapping_prev(*args) -> lvar_mapping_iterator_t: ...
def lvar_mapping_erase(*args) -> None: ...
def lvar_mapping_clear(*args) -> None: ...
def lvar_mapping_size(*args) -> size_t: ...
def lvar_mapping_free(*args) -> None: ...
def lvar_mapping_new(*args) -> 'lvar_mapping_t *': ...

class udcall_map_iterator_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    x: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

def udcall_map_first(*args) -> 'ea_t const &': ...
def udcall_map_second(*args) -> 'udcall_t &': ...
def udcall_map_find(*args) -> udcall_map_iterator_t: ...
def udcall_map_insert(*args) -> udcall_map_iterator_t: ...
def udcall_map_begin(*args) -> udcall_map_iterator_t: ...
def udcall_map_end(*args) -> udcall_map_iterator_t: ...
def udcall_map_next(*args) -> udcall_map_iterator_t: ...
def udcall_map_prev(*args) -> udcall_map_iterator_t: ...
def udcall_map_erase(*args) -> None: ...
def udcall_map_clear(*args) -> None: ...
def udcall_map_size(*args) -> size_t: ...
def udcall_map_free(*args) -> None: ...
def udcall_map_new(*args) -> 'udcall_map_t *': ...

class user_cmts_iterator_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    x: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

def user_cmts_first(*args) -> 'treeloc_t const &': ...
def user_cmts_second(*args) -> 'citem_cmt_t &': ...
def user_cmts_find(*args) -> user_cmts_iterator_t: ...
def user_cmts_insert(*args) -> user_cmts_iterator_t: ...
def user_cmts_begin(*args) -> user_cmts_iterator_t: ...
def user_cmts_end(*args) -> user_cmts_iterator_t: ...
def user_cmts_next(*args) -> user_cmts_iterator_t: ...
def user_cmts_prev(*args) -> user_cmts_iterator_t: ...
def user_cmts_erase(*args) -> None: ...
def user_cmts_clear(*args) -> None: ...
def user_cmts_size(*args) -> size_t: ...
def user_cmts_free(*args) -> None: ...
def user_cmts_new(*args) -> 'user_cmts_t *': ...

class user_iflags_iterator_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    x: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

def user_iflags_first(*args) -> 'citem_locator_t const &': ...
def user_iflags_find(*args) -> user_iflags_iterator_t: ...
def user_iflags_insert(*args) -> user_iflags_iterator_t: ...
def user_iflags_begin(*args) -> user_iflags_iterator_t: ...
def user_iflags_end(*args) -> user_iflags_iterator_t: ...
def user_iflags_next(*args) -> user_iflags_iterator_t: ...
def user_iflags_prev(*args) -> user_iflags_iterator_t: ...
def user_iflags_erase(*args) -> None: ...
def user_iflags_clear(*args) -> None: ...
def user_iflags_size(*args) -> size_t: ...
def user_iflags_free(*args) -> None: ...
def user_iflags_new(*args) -> 'user_iflags_t *': ...

class user_unions_iterator_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    x: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

def user_unions_first(*args) -> 'ea_t const &': ...
def user_unions_second(*args) -> 'intvec_t &': ...
def user_unions_find(*args) -> user_unions_iterator_t: ...
def user_unions_insert(*args) -> user_unions_iterator_t: ...
def user_unions_begin(*args) -> user_unions_iterator_t: ...
def user_unions_end(*args) -> user_unions_iterator_t: ...
def user_unions_next(*args) -> user_unions_iterator_t: ...
def user_unions_prev(*args) -> user_unions_iterator_t: ...
def user_unions_erase(*args) -> None: ...
def user_unions_clear(*args) -> None: ...
def user_unions_size(*args) -> size_t: ...
def user_unions_free(*args) -> None: ...
def user_unions_new(*args) -> 'user_unions_t *': ...

class user_labels_iterator_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    x: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

def user_labels_first(*args) -> 'int const &': ...
def user_labels_second(*args) -> 'qstring &': ...
def user_labels_find(*args) -> user_labels_iterator_t: ...
def user_labels_insert(*args) -> user_labels_iterator_t: ...
def user_labels_begin(*args) -> user_labels_iterator_t: ...
def user_labels_end(*args) -> user_labels_iterator_t: ...
def user_labels_next(*args) -> user_labels_iterator_t: ...
def user_labels_prev(*args) -> user_labels_iterator_t: ...
def user_labels_erase(*args) -> None: ...
def user_labels_clear(*args) -> None: ...
def user_labels_size(*args) -> size_t: ...
def user_labels_free(*args) -> None: ...
def user_labels_new(*args) -> 'user_labels_t *': ...

class eamap_iterator_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    x: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

def eamap_first(*args) -> 'ea_t const &': ...
def eamap_second(*args) -> 'cinsnptrvec_t &': ...
def eamap_find(*args) -> eamap_iterator_t: ...
def eamap_insert(*args) -> eamap_iterator_t: ...
def eamap_begin(*args) -> eamap_iterator_t: ...
def eamap_end(*args) -> eamap_iterator_t: ...
def eamap_next(*args) -> eamap_iterator_t: ...
def eamap_prev(*args) -> eamap_iterator_t: ...
def eamap_erase(*args) -> None: ...
def eamap_clear(*args) -> None: ...
def eamap_size(*args) -> size_t: ...
def eamap_free(*args) -> None: ...
def eamap_new(*args) -> 'eamap_t *': ...

class boundaries_iterator_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    x: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

def boundaries_first(*args) -> 'cinsn_t *const &': ...
def boundaries_second(*args) -> 'rangeset_t &': ...
def boundaries_begin(*args) -> boundaries_iterator_t: ...
def boundaries_end(*args) -> boundaries_iterator_t: ...
def boundaries_next(*args) -> boundaries_iterator_t: ...
def boundaries_prev(*args) -> boundaries_iterator_t: ...
def boundaries_erase(*args) -> None: ...
def boundaries_clear(*args) -> None: ...
def boundaries_size(*args) -> size_t: ...
def boundaries_free(*args) -> None: ...
def boundaries_new(*args) -> 'boundaries_t *': ...

class block_chains_iterator_t:
    thisown: Incomplete
    __repr__ = _swig_repr
    x: Incomplete
    def __eq__(self, *args) -> bool: ...
    def __ne__(self, *args) -> bool: ...
    def __init__(self, *args) -> None: ...
    __swig_destroy__: Incomplete

def block_chains_get(*args) -> 'chain_t &': ...
def block_chains_find(*args) -> block_chains_iterator_t: ...
def block_chains_insert(*args) -> block_chains_iterator_t: ...
def block_chains_begin(*args) -> block_chains_iterator_t: ...
def block_chains_end(*args) -> block_chains_iterator_t: ...
def block_chains_next(*args) -> block_chains_iterator_t: ...
def block_chains_prev(*args) -> block_chains_iterator_t: ...
def block_chains_erase(*args) -> None: ...
def block_chains_clear(*args) -> None: ...
def block_chains_size(*args) -> size_t: ...
def block_chains_free(*args) -> None: ...
def block_chains_new(*args) -> 'block_chains_t *': ...
is_allowed_on_small_struni = accepts_small_udts
is_small_struni = is_small_udt
mbl_array_t = mba_t

class DecompilationFailure(Exception): ...

def citem_to_specific_type(self): ...
def property_op_to_typename(self): ...
def cexpr_operands(self): ...
def cinsn_details(self): ...
def cfunc_type(self): ...
def _map_as_dict(maptype, name, keytype, valuetype): ...
def _call_with_transferrable_ownership(fun, *args): ...
def lnot(e): ...
def make_ref(e): ...
def dereference(e, ptrsize, is_float: bool = False): ...
def call_helper(rettype, args, *rest): ...
def new_block(): ...
def make_num(*args): ...
def create_helper(*args): ...

class __cbhooks_t(Hexrays_Hooks):
    instances: Incomplete
    callback: Incomplete
    def __init__(self, callback) -> None: ...
    def maturity(self, *args): ...
    def interr(self, *args): ...
    def print_func(self, *args): ...
    def func_printed(self, *args): ...
    def open_pseudocode(self, *args): ...
    def switch_pseudocode(self, *args): ...
    def refresh_pseudocode(self, *args): ...
    def close_pseudocode(self, *args): ...
    def keyboard(self, *args): ...
    def right_click(self, *args): ...
    def double_click(self, *args): ...
    def curpos(self, *args): ...
    def create_hint(self, *args): ...
    def text_ready(self, *args): ...
    def populating_popup(self, *args): ...

def install_hexrays_callback(callback): ...
def remove_hexrays_callback(callback): ...
